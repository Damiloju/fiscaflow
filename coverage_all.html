
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">fiscaflow/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">fiscaflow/internal/api/handlers/transaction.go (15.7%)</option>
				
				<option value="file2">fiscaflow/internal/api/handlers/user.go (39.2%)</option>
				
				<option value="file3">fiscaflow/internal/api/middleware/auth.go (0.0%)</option>
				
				<option value="file4">fiscaflow/internal/api/routes/routes.go (0.0%)</option>
				
				<option value="file5">fiscaflow/internal/api/server/server.go (0.0%)</option>
				
				<option value="file6">fiscaflow/internal/config/config.go (0.0%)</option>
				
				<option value="file7">fiscaflow/internal/domain/transaction/model.go (0.0%)</option>
				
				<option value="file8">fiscaflow/internal/domain/transaction/repository.go (0.0%)</option>
				
				<option value="file9">fiscaflow/internal/domain/transaction/service.go (23.6%)</option>
				
				<option value="file10">fiscaflow/internal/domain/user/model.go (0.0%)</option>
				
				<option value="file11">fiscaflow/internal/domain/user/repository.go (0.0%)</option>
				
				<option value="file12">fiscaflow/internal/domain/user/service.go (47.2%)</option>
				
				<option value="file13">fiscaflow/internal/infrastructure/database/postgres.go (0.0%)</option>
				
				<option value="file14">fiscaflow/internal/observability/logging/logger.go (0.0%)</option>
				
				<option value="file15">fiscaflow/internal/observability/tracing/tracer.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/otel"
        "go.uber.org/zap"

        "fiscaflow/internal/api/server"
        "fiscaflow/internal/config"
        "fiscaflow/internal/observability/logging"
        "fiscaflow/internal/observability/tracing"

        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func main() <span class="cov0" title="0">{
        // Initialize logger
        logger := logging.NewLogger()
        defer logger.Sync()

        logger.Info("Starting FiscaFlow application...")

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to load configuration", zap.Error(err))
        }</span>

        // Initialize OpenTelemetry tracer
        <span class="cov0" title="0">tracer, err := tracing.InitTracer(cfg.OpenTelemetry.Endpoint)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize tracer", zap.Error(err))
        }</span>
        <span class="cov0" title="0">defer tracing.ShutdownTracer(tracer, context.Background())

        // Set global tracer
        otel.SetTracerProvider(tracer)

        // Create Gin router
        router := gin.New()

        // Add middleware
        router.Use(gin.Recovery())
        router.Use(logging.GinLogger(logger))

        // Initialize and setup API server
        apiServer := server.New(cfg, logger)
        apiServer.SetupRoutes(router)

        // Health check endpoint
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().UTC(),
                        "service":   "fiscaflow",
                        "version":   "1.0.0",
                })
        }</span>)

        // Ready check endpoint
        <span class="cov0" title="0">router.GET("/ready", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":    "ready",
                        "timestamp": time.Now().UTC(),
                })
        }</span>)

        // Serve Swagger UI and OpenAPI spec
        <span class="cov0" title="0">router.GET("/swagger/doc.json", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("docs/swagger.yaml")
        }</span>)
        <span class="cov0" title="0">router.GET("/swagger/", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/swagger/doc.json")))
        router.GET("/swagger/index.html", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/swagger/doc.json")))

        // Start server
        srv := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
                Handler: router,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting HTTP server", zap.String("address", srv.Addr))
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start server", zap.Error(err))
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        // Create a deadline for server shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Attempt graceful shutdown
        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"

        "fiscaflow/internal/domain/transaction"
)

// TransactionHandler handles transaction-related HTTP requests
type TransactionHandler struct {
        Service transaction.Service
}

// NewTransactionHandler creates a new TransactionHandler
func NewTransactionHandler(service transaction.Service) *TransactionHandler <span class="cov8" title="1">{
        return &amp;TransactionHandler{Service: service}
}</span>

// RegisterRoutes registers transaction routes
func (h *TransactionHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov8" title="1">{
        tr := rg.Group("/transactions")
        tr.POST("", h.CreateTransaction)
        tr.GET("", h.ListTransactions)
        tr.GET(":id", h.GetTransaction)
        tr.PUT(":id", h.UpdateTransaction)
        tr.DELETE(":id", h.DeleteTransaction)
}</span>

// CreateTransaction handles POST /transactions
func (h *TransactionHandler) CreateTransaction(c *gin.Context) <span class="cov8" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "CreateTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov8" title="1">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov8" title="1">var req transaction.CreateTransactionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">resp, err := h.Service.CreateTransaction(ctx, uid, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusCreated, resp)</span>
}

// GetTransaction handles GET /transactions/:id
func (h *TransactionHandler) GetTransaction(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "GetTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid transaction id"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Service.GetTransaction(ctx, uid, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrTransactionNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "transaction not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// ListTransactions handles GET /transactions
func (h *TransactionHandler) ListTransactions(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "ListTransactions")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>
        <span class="cov0" title="0">offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        resp, err := h.Service.GetTransactions(ctx, uid, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// UpdateTransaction handles PUT /transactions/:id
func (h *TransactionHandler) UpdateTransaction(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "UpdateTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid transaction id"})
                return
        }</span>

        <span class="cov0" title="0">var req transaction.UpdateTransactionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Service.UpdateTransaction(ctx, uid, id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrTransactionNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "transaction not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// DeleteTransaction handles DELETE /transactions/:id
func (h *TransactionHandler) DeleteTransaction(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "DeleteTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid transaction id"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.Service.DeleteTransaction(ctx, uid, id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrTransactionNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "transaction not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.uber.org/zap"

        "fiscaflow/internal/domain/user"
)

// UserHandler handles user-related HTTP requests
type UserHandler struct {
        userService user.Service
        logger      *zap.Logger
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService user.Service, logger *zap.Logger) *UserHandler <span class="cov10" title="10">{
        return &amp;UserHandler{
                userService: userService,
                logger:      logger,
        }
}</span>

// Register handles user registration
func (h *UserHandler) Register(c *gin.Context) <span class="cov5" title="3">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.Register")
        defer span.End()

        var req user.CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(
                attribute.String("user.email", req.Email),
                attribute.String("user.first_name", req.FirstName),
                attribute.String("user.last_name", req.LastName),
        )

        userResponse, err := h.userService.Register(ctx, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrUserAlreadyExists:<span class="cov1" title="1">
                        c.JSON(http.StatusConflict, gin.H{"error": "User already exists"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to register user", zap.Error(err), zap.String("email", req.Email))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register user"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetAttributes(attribute.String("user.id", userResponse.ID.String()))
        span.SetStatus(codes.Ok, "user registered successfully")

        c.JSON(http.StatusCreated, gin.H{
                "message": "User registered successfully",
                "user":    userResponse,
        })</span>
}

// Login handles user login
func (h *UserHandler) Login(c *gin.Context) <span class="cov3" title="2">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.Login")
        defer span.End()

        var req user.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(attribute.String("user.email", req.Email))

        loginResponse, err := h.userService.Login(ctx, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrInvalidCredentials:<span class="cov1" title="1">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})</span>
                case user.ErrUserInactive:<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": "User account is inactive"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to login user", zap.Error(err), zap.String("email", req.Email))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to login"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetAttributes(
                attribute.String("user.id", loginResponse.User.ID.String()),
                attribute.String("user.role", string(loginResponse.User.Role)),
        )
        span.SetStatus(codes.Ok, "user logged in successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Login successful",
                "data":    loginResponse,
        })</span>
}

// GetProfile retrieves user profile
func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov5" title="3">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.GetProfile")
        defer span.End()

        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov1" title="1">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "user_id not found in context")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "invalid user_id type")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(attribute.String("user.id", userUUID.String()))

        userResponse, err := h.userService.GetProfile(ctx, userUUID)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrUserNotFound:<span class="cov1" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to get user profile", zap.Error(err), zap.String("user_id", userUUID.String()))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get profile"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "profile retrieved successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Profile retrieved successfully",
                "user":    userResponse,
        })</span>
}

// UpdateProfile updates user profile
func (h *UserHandler) UpdateProfile(c *gin.Context) <span class="cov3" title="2">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.UpdateProfile")
        defer span.End()

        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "user_id not found in context")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "invalid user_id type")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">var req user.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(attribute.String("user.id", userUUID.String()))

        userResponse, err := h.userService.UpdateProfile(ctx, userUUID, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrUserNotFound:<span class="cov1" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to update user profile", zap.Error(err), zap.String("user_id", userUUID.String()))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "profile updated successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Profile updated successfully",
                "user":    userResponse,
        })</span>
}

// RefreshToken refreshes access token
func (h *UserHandler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.RefreshToken")
        defer span.End()

        var req struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String("refresh_token", req.RefreshToken))

        loginResponse, err := h.userService.RefreshToken(ctx, req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrInvalidRefreshToken:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid refresh token"})</span>
                case user.ErrRefreshTokenExpired:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Refresh token expired"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to refresh token", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to refresh token"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">span.SetAttributes(attribute.String("user.id", loginResponse.User.ID.String()))
        span.SetStatus(codes.Ok, "token refreshed successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Token refreshed successfully",
                "data":    loginResponse,
        })</span>
}

// Logout handles user logout
func (h *UserHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.Logout")
        defer span.End()

        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "user_id not found in context")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "invalid user_id type")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        // Get session ID from header or query param
        <span class="cov0" title="0">sessionIDStr := c.GetHeader("X-Session-ID")
        if sessionIDStr == "" </span><span class="cov0" title="0">{
                sessionIDStr = c.Query("session_id")
        }</span>

        <span class="cov0" title="0">if sessionIDStr == "" </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "session_id not provided")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Session ID is required"})
                return
        }</span>

        <span class="cov0" title="0">sessionID, err := uuid.Parse(sessionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid session_id format")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid session ID format"})
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("user.id", userUUID.String()),
                attribute.String("session.id", sessionID.String()),
        )

        if err := h.userService.Logout(ctx, userUUID, sessionID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                h.logger.Error("Failed to logout user", zap.Error(err), zap.String("user_id", userUUID.String()))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to logout"})
                return
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user logged out successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Logged out successfully",
        })</span>
}

// ListUsers handles listing users (admin only)
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.ListUsers")
        defer span.End()

        // Get pagination parameters
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.Int("offset", offset),
                attribute.Int("limit", limit),
        )

        users, err := h.userService.(interface {
                List(ctx context.Context, offset, limit int) ([]user.User, error)
        }).List(ctx, offset, limit)

        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                h.logger.Error("Failed to list users", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list users"})
                return
        }</span>

        // Convert to responses
        <span class="cov0" title="0">userResponses := make([]*user.UserResponse, len(users))
        for i, u := range users </span><span class="cov0" title="0">{
                userResponses[i] = &amp;user.UserResponse{
                        ID:            u.ID,
                        Email:         u.Email,
                        FirstName:     u.FirstName,
                        LastName:      u.LastName,
                        Phone:         u.Phone,
                        DateOfBirth:   u.DateOfBirth,
                        Timezone:      u.Timezone,
                        Locale:        u.Locale,
                        Role:          u.Role,
                        Status:        u.Status,
                        EmailVerified: u.EmailVerified,
                        PhoneVerified: u.PhoneVerified,
                        LastLoginAt:   u.LastLoginAt,
                        CreatedAt:     u.CreatedAt,
                        UpdatedAt:     u.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "users listed successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Users retrieved successfully",
                "users":   userResponses,
                "pagination": gin.H{
                        "offset": offset,
                        "limit":  limit,
                        "count":  len(userResponses),
                },
        })</span>
}

// RegisterRoutes registers user-related routes
func (h *UserHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov0" title="0">{
        rg.POST("/users/register", h.Register)
        rg.POST("/users/login", h.Login)
        rg.GET("/users/profile", h.GetProfile)
        rg.PUT("/users/profile", h.UpdateProfile)
        rg.POST("/users/refresh-token", h.RefreshToken)
        rg.POST("/users/logout", h.Logout)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "fiscaflow/internal/domain/user"
)

// AuthMiddleware creates authentication middleware
func AuthMiddleware(userService user.Service) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Authorization header is required",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if it's a Bearer token
                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Invalid authorization header format",
                        })
                        c.Abort()
                        return
                }</span>

                // Extract token
                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")

                // Validate token
                claims, err := userService.ValidateToken(c.Request.Context(), token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Invalid or expired token",
                        })
                        c.Abort()
                        return
                }</span>

                // Set user ID in context
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Set("user_role", claims.Role)

                c.Next()</span>
        }
}

// GetUserIDFromContext extracts user ID from gin context
func GetUserIDFromContext(c *gin.Context) (uuid.UUID, bool) <span class="cov0" title="0">{
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return uuid.Nil, false
        }</span>

        <span class="cov0" title="0">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                return uuid.Nil, false
        }</span>

        <span class="cov0" title="0">return userID, true</span>
}

// GetUserEmailFromContext extracts user email from gin context
func GetUserEmailFromContext(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        emailInterface, exists := c.Get("user_email")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">email, ok := emailInterface.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">return email, true</span>
}

// GetUserRoleFromContext extracts user role from gin context
func GetUserRoleFromContext(c *gin.Context) (user.UserRole, bool) <span class="cov0" title="0">{
        roleInterface, exists := c.Get("user_role")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">role, ok := roleInterface.(user.UserRole)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">return role, true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package routes

import (
        "fiscaflow/internal/api/handlers"

        "github.com/gin-gonic/gin"
)

// RegisterAPIRoutes registers all API routes
func RegisterAPIRoutes(r *gin.Engine, userHandler *handlers.UserHandler, transactionHandler *handlers.TransactionHandler) <span class="cov0" title="0">{
        api := r.Group("/api/v1")

        // User routes (assume already registered)
        userHandler.RegisterRoutes(api)

        // Transaction routes (protected)
        api.Use(AuthMiddleware()) // Assume AuthMiddleware sets user_id in context
        transactionHandler.RegisterRoutes(api)
}</span>

// AuthMiddleware is a placeholder for the actual authentication middleware
func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // This should set user_id in context after validating JWT
                // For now, assume user_id is set for testing
                // c.Set("user_id", uuid.MustParse("00000000-0000-0000-0000-000000000001"))
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package server

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"

        "fiscaflow/internal/api/handlers"
        "fiscaflow/internal/api/middleware"
        "fiscaflow/internal/config"
        "fiscaflow/internal/domain/transaction"
        "fiscaflow/internal/domain/user"
        "fiscaflow/internal/infrastructure/database"
)

// Server represents the API server
type Server struct {
        config             *config.Config
        logger             *zap.Logger
        userService        user.Service
        userHandler        *handlers.UserHandler
        transactionService transaction.Service
        transactionHandler *handlers.TransactionHandler
}

// New creates a new API server instance
func New(cfg *config.Config, logger *zap.Logger) *Server <span class="cov0" title="0">{
        // Initialize database
        dbConfig := &amp;database.Config{
                Host:            cfg.Database.Host,
                Port:            cfg.Database.Port,
                User:            cfg.Database.User,
                Password:        cfg.Database.Password,
                DBName:          cfg.Database.DBName,
                SSLMode:         cfg.Database.SSLMode,
                MaxOpenConns:    cfg.Database.MaxOpenConns,
                MaxIdleConns:    cfg.Database.MaxIdleConns,
                ConnMaxLifetime: cfg.Database.ConnMaxLifetime,
        }

        db, err := database.NewDatabase(dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to connect to database", zap.Error(err))
        }</span>

        // Auto-migrate database
        <span class="cov0" title="0">if err := db.AutoMigrate(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to run database migrations", zap.Error(err))
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">userRepo := user.NewRepository(db.GetDB())
        transactionRepo := transaction.NewRepository(db.GetDB())

        // Initialize services
        userService := user.NewService(userRepo, cfg.JWT.Secret)
        transactionService := transaction.NewService(transactionRepo)

        // Initialize handlers
        userHandler := handlers.NewUserHandler(userService, logger)
        transactionHandler := handlers.NewTransactionHandler(transactionService)

        return &amp;Server{
                config:             cfg,
                logger:             logger,
                userService:        userService,
                userHandler:        userHandler,
                transactionService: transactionService,
                transactionHandler: transactionHandler,
        }</span>
}

// SetupRoutes configures all API routes
func (s *Server) SetupRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // API v1 group
        v1 := router.Group("/api/v1")

        // User routes
        users := v1.Group("/users")
        </span><span class="cov0" title="0">{
                users.POST("/register", s.userHandler.Register)
                users.POST("/login", s.userHandler.Login)
                users.POST("/logout", s.userHandler.Logout)
                users.POST("/refresh", s.userHandler.RefreshToken)

                // Protected routes
                protected := users.Group("")
                protected.Use(middleware.AuthMiddleware(s.userService))
                </span><span class="cov0" title="0">{
                        protected.GET("/profile", s.userHandler.GetProfile)
                        protected.PUT("/profile", s.userHandler.UpdateProfile)
                }</span>
        }

        // Transaction routes (protected)
        <span class="cov0" title="0">transactions := v1.Group("/transactions")
        transactions.Use(middleware.AuthMiddleware(s.userService))
        </span><span class="cov0" title="0">{
                transactions.POST("", s.transactionHandler.CreateTransaction)
                transactions.GET("", s.transactionHandler.ListTransactions)
                transactions.GET(":id", s.transactionHandler.GetTransaction)
                transactions.PUT(":id", s.transactionHandler.UpdateTransaction)
                transactions.DELETE(":id", s.transactionHandler.DeleteTransaction)
        }</span>

        <span class="cov0" title="0">s.logger.Info("API routes configured")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// Config holds all configuration for the application
type Config struct {
        Server        ServerConfig
        Database      DatabaseConfig
        Redis         RedisConfig
        OpenTelemetry OpenTelemetryConfig
        JWT           JWTConfig
        Elasticsearch ElasticsearchConfig
        MinIO         MinIOConfig
        RabbitMQ      RabbitMQConfig
}

// ServerConfig holds server configuration
type ServerConfig struct {
        Port         int
        Host         string
        ReadTimeout  time.Duration
        WriteTimeout time.Duration
        IdleTimeout  time.Duration
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Host            string
        Port            int
        User            string
        Password        string
        DBName          string
        SSLMode         string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
        Host     string
        Port     int
        Password string
        DB       int
}

// OpenTelemetryConfig holds OpenTelemetry configuration
type OpenTelemetryConfig struct {
        Endpoint       string
        ServiceName    string
        ServiceVersion string
}

// JWTConfig holds JWT configuration
type JWTConfig struct {
        Secret            string
        Expiration        time.Duration
        RefreshExpiration time.Duration
}

// ElasticsearchConfig holds Elasticsearch configuration
type ElasticsearchConfig struct {
        URL      string
        Username string
        Password string
}

// MinIOConfig holds MinIO configuration
type MinIOConfig struct {
        Endpoint        string
        AccessKeyID     string
        SecretAccessKey string
        UseSSL          bool
}

// RabbitMQConfig holds RabbitMQ configuration
type RabbitMQConfig struct {
        URL      string
        Username string
        Password string
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists
        if err := godotenv.Load(); err != nil </span>{<span class="cov0" title="0">
                // .env file is optional, so we don't return error
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Server: ServerConfig{
                        Port:         getEnvAsInt("SERVER_PORT", 8080),
                        Host:         getEnv("SERVER_HOST", "0.0.0.0"),
                        ReadTimeout:  getEnvAsDuration("SERVER_READ_TIMEOUT", 15*time.Second),
                        WriteTimeout: getEnvAsDuration("SERVER_WRITE_TIMEOUT", 15*time.Second),
                        IdleTimeout:  getEnvAsDuration("SERVER_IDLE_TIMEOUT", 60*time.Second),
                },
                Database: DatabaseConfig{
                        Host:            getEnv("DATABASE_HOST", "localhost"),
                        Port:            getEnvAsInt("DATABASE_PORT", 5432),
                        User:            getEnv("DATABASE_USER", "postgres"),
                        Password:        getEnv("DATABASE_PASSWORD", "password"),
                        DBName:          getEnv("DATABASE_NAME", "fiscaflow"),
                        SSLMode:         getEnv("DATABASE_SSL_MODE", "disable"),
                        MaxOpenConns:    getEnvAsInt("DATABASE_MAX_OPEN_CONNS", 25),
                        MaxIdleConns:    getEnvAsInt("DATABASE_MAX_IDLE_CONNS", 5),
                        ConnMaxLifetime: getEnvAsDuration("DATABASE_CONN_MAX_LIFETIME", 5*time.Minute),
                },
                Redis: RedisConfig{
                        Host:     getEnv("REDIS_HOST", "localhost"),
                        Port:     getEnvAsInt("REDIS_PORT", 6379),
                        Password: getEnv("REDIS_PASSWORD", ""),
                        DB:       getEnvAsInt("REDIS_DB", 0),
                },
                OpenTelemetry: OpenTelemetryConfig{
                        Endpoint:       getEnv("OTEL_ENDPOINT", "jaeger:4317"),
                        ServiceName:    getEnv("OTEL_SERVICE_NAME", "fiscaflow"),
                        ServiceVersion: getEnv("OTEL_SERVICE_VERSION", "1.0.0"),
                },
                JWT: JWTConfig{
                        Secret:            getEnv("JWT_SECRET", "your-secret-key"),
                        Expiration:        getEnvAsDuration("JWT_EXPIRATION", 15*time.Minute),
                        RefreshExpiration: getEnvAsDuration("JWT_REFRESH_EXPIRATION", 7*24*time.Hour),
                },
                Elasticsearch: ElasticsearchConfig{
                        URL:      getEnv("ELASTICSEARCH_URL", "http://localhost:9200"),
                        Username: getEnv("ELASTICSEARCH_USERNAME", ""),
                        Password: getEnv("ELASTICSEARCH_PASSWORD", ""),
                },
                MinIO: MinIOConfig{
                        Endpoint:        getEnv("MINIO_ENDPOINT", "localhost:9000"),
                        AccessKeyID:     getEnv("MINIO_ACCESS_KEY_ID", "minioadmin"),
                        SecretAccessKey: getEnv("MINIO_SECRET_ACCESS_KEY", "minioadmin"),
                        UseSSL:          getEnvAsBool("MINIO_USE_SSL", false),
                },
                RabbitMQ: RabbitMQConfig{
                        URL:      getEnv("RABBITMQ_URL", "amqp://guest:guest@localhost:5672/"),
                        Username: getEnv("RABBITMQ_USERNAME", "guest"),
                        Password: getEnv("RABBITMQ_PASSWORD", "guest"),
                },
        }

        return config, nil</span>
}

// GetDSN returns the database connection string
func (c *DatabaseConfig) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.DBName, c.SSLMode)
}</span>

// GetRedisAddr returns the Redis address
func (c *RedisConfig) GetAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>

// Helper functions
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package transaction

import (
        "time"

        "github.com/google/uuid"
)

// Transaction represents a financial transaction
type Transaction struct {
        ID         uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID     uuid.UUID  `json:"user_id" gorm:"type:uuid;not null"`
        FamilyID   *uuid.UUID `json:"family_id" gorm:"type:uuid"`
        AccountID  uuid.UUID  `json:"account_id" gorm:"type:uuid;not null"`
        CategoryID *uuid.UUID `json:"category_id" gorm:"type:uuid"`

        Amount      float64 `json:"amount" gorm:"type:decimal(15,2);not null"`
        Currency    string  `json:"currency" gorm:"default:'USD'"`
        Description string  `json:"description" gorm:"not null"`
        Merchant    string  `json:"merchant"`
        Location    string  `json:"location" gorm:"type:jsonb"`

        TransactionDate time.Time         `json:"transaction_date" gorm:"not null"`
        PostedDate      *time.Time        `json:"posted_date"`
        Status          TransactionStatus `json:"status" gorm:"default:'pending'"`

        CategorizationSource     CategorizationSource `json:"categorization_source" gorm:"default:'manual'"`
        CategorizationConfidence *float64             `json:"categorization_confidence"`

        Tags       []string `json:"tags" gorm:"type:text[]"`
        Notes      string   `json:"notes"`
        ReceiptURL string   `json:"receipt_url"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// TransactionStatus represents the status of a transaction
type TransactionStatus string

const (
        TransactionStatusPending   TransactionStatus = "pending"
        TransactionStatusPosted    TransactionStatus = "posted"
        TransactionStatusCancelled TransactionStatus = "cancelled"
        TransactionStatusDisputed  TransactionStatus = "disputed"
)

// CategorizationSource represents how the transaction was categorized
type CategorizationSource string

const (
        CategorizationSourceManual         CategorizationSource = "manual"
        CategorizationSourceML             CategorizationSource = "ml"
        CategorizationSourcePlaid          CategorizationSource = "plaid"
        CategorizationSourceUserCorrection CategorizationSource = "user_correction"
)

// Category represents a transaction category
type Category struct {
        ID          uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Name        string     `json:"name" gorm:"not null"`
        Description string     `json:"description"`
        Icon        string     `json:"icon"`
        Color       string     `json:"color"`
        ParentID    *uuid.UUID `json:"parent_id" gorm:"type:uuid"`
        IsDefault   bool       `json:"is_default" gorm:"default:false"`
        IsActive    bool       `json:"is_active" gorm:"default:true"`
        SortOrder   int        `json:"sort_order" gorm:"default:0"`
        CreatedAt   time.Time  `json:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at"`
}

// Account represents a financial account
type Account struct {
        ID                uuid.UUID   `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID            uuid.UUID   `json:"user_id" gorm:"type:uuid;not null"`
        FamilyID          *uuid.UUID  `json:"family_id" gorm:"type:uuid"`
        Name              string      `json:"name" gorm:"not null"`
        Type              AccountType `json:"type" gorm:"not null"`
        Institution       string      `json:"institution"`
        AccountNumberHash string      `json:"account_number_hash"`
        Balance           float64     `json:"balance" gorm:"type:decimal(15,2);default:0.00"`
        Currency          string      `json:"currency" gorm:"default:'USD'"`
        IsActive          bool        `json:"is_active" gorm:"default:true"`
        PlaidAccountID    string      `json:"plaid_account_id"`
        LastSyncAt        *time.Time  `json:"last_sync_at"`
        Settings          string      `json:"settings" gorm:"type:jsonb;default:'{}'"`
        CreatedAt         time.Time   `json:"created_at"`
        UpdatedAt         time.Time   `json:"updated_at"`
}

// AccountType represents the type of account
type AccountType string

const (
        AccountTypeChecking   AccountType = "checking"
        AccountTypeSavings    AccountType = "savings"
        AccountTypeCreditCard AccountType = "credit_card"
        AccountTypeInvestment AccountType = "investment"
        AccountTypeLoan       AccountType = "loan"
        AccountTypeOther      AccountType = "other"
)

// CreateTransactionRequest represents a request to create a new transaction
type CreateTransactionRequest struct {
        AccountID       uuid.UUID  `json:"account_id" binding:"required"`
        CategoryID      *uuid.UUID `json:"category_id"`
        Amount          float64    `json:"amount" binding:"required"`
        Currency        string     `json:"currency"`
        Description     string     `json:"description" binding:"required"`
        Merchant        string     `json:"merchant"`
        Location        string     `json:"location"`
        TransactionDate time.Time  `json:"transaction_date" binding:"required"`
        PostedDate      *time.Time `json:"posted_date"`
        Tags            []string   `json:"tags"`
        Notes           string     `json:"notes"`
}

// UpdateTransactionRequest represents a request to update a transaction
type UpdateTransactionRequest struct {
        CategoryID      *uuid.UUID         `json:"category_id"`
        Amount          *float64           `json:"amount"`
        Currency        string             `json:"currency"`
        Description     string             `json:"description"`
        Merchant        string             `json:"merchant"`
        Location        string             `json:"location"`
        TransactionDate *time.Time         `json:"transaction_date"`
        PostedDate      *time.Time         `json:"posted_date"`
        Status          *TransactionStatus `json:"status"`
        Tags            []string           `json:"tags"`
        Notes           string             `json:"notes"`
}

// TransactionResponse represents a transaction response
type TransactionResponse struct {
        ID                       uuid.UUID            `json:"id"`
        UserID                   uuid.UUID            `json:"user_id"`
        FamilyID                 *uuid.UUID           `json:"family_id"`
        AccountID                uuid.UUID            `json:"account_id"`
        CategoryID               *uuid.UUID           `json:"category_id"`
        Amount                   float64              `json:"amount"`
        Currency                 string               `json:"currency"`
        Description              string               `json:"description"`
        Merchant                 string               `json:"merchant"`
        Location                 string               `json:"location"`
        TransactionDate          time.Time            `json:"transaction_date"`
        PostedDate               *time.Time           `json:"posted_date"`
        Status                   TransactionStatus    `json:"status"`
        CategorizationSource     CategorizationSource `json:"categorization_source"`
        CategorizationConfidence *float64             `json:"categorization_confidence"`
        Tags                     []string             `json:"tags"`
        Notes                    string               `json:"notes"`
        ReceiptURL               string               `json:"receipt_url"`
        CreatedAt                time.Time            `json:"created_at"`
        UpdatedAt                time.Time            `json:"updated_at"`
}

// CreateCategoryRequest represents a request to create a new category
type CreateCategoryRequest struct {
        Name        string     `json:"name" binding:"required"`
        Description string     `json:"description"`
        Icon        string     `json:"icon"`
        Color       string     `json:"color"`
        ParentID    *uuid.UUID `json:"parent_id"`
        IsDefault   bool       `json:"is_default"`
        SortOrder   int        `json:"sort_order"`
}

// CreateAccountRequest represents a request to create a new account
type CreateAccountRequest struct {
        Name              string      `json:"name" binding:"required"`
        Type              AccountType `json:"type" binding:"required"`
        Institution       string      `json:"institution"`
        AccountNumberHash string      `json:"account_number_hash"`
        Balance           float64     `json:"balance"`
        Currency          string      `json:"currency"`
        PlaidAccountID    string      `json:"plaid_account_id"`
}

// TableName specifies the table name for Transaction
func (Transaction) TableName() string <span class="cov0" title="0">{
        return "transactions"
}</span>

// TableName specifies the table name for Category
func (Category) TableName() string <span class="cov0" title="0">{
        return "categories"
}</span>

// TableName specifies the table name for Account
func (Account) TableName() string <span class="cov0" title="0">{
        return "accounts"
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package transaction

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository defines the interface for transaction data operations
type Repository interface {
        // Transaction operations
        CreateTransaction(ctx context.Context, transaction *Transaction) error
        GetTransactionByID(ctx context.Context, id uuid.UUID) (*Transaction, error)
        GetTransactionsByUser(ctx context.Context, userID uuid.UUID, offset, limit int) ([]Transaction, error)
        GetTransactionsByAccount(ctx context.Context, accountID uuid.UUID, offset, limit int) ([]Transaction, error)
        UpdateTransaction(ctx context.Context, transaction *Transaction) error
        DeleteTransaction(ctx context.Context, id uuid.UUID) error

        // Category operations
        CreateCategory(ctx context.Context, category *Category) error
        GetCategoryByID(ctx context.Context, id uuid.UUID) (*Category, error)
        GetCategories(ctx context.Context, offset, limit int) ([]Category, error)
        GetDefaultCategories(ctx context.Context) ([]Category, error)
        UpdateCategory(ctx context.Context, category *Category) error
        DeleteCategory(ctx context.Context, id uuid.UUID) error

        // Account operations
        CreateAccount(ctx context.Context, account *Account) error
        GetAccountByID(ctx context.Context, id uuid.UUID) (*Account, error)
        GetAccountsByUser(ctx context.Context, userID uuid.UUID) ([]Account, error)
        UpdateAccount(ctx context.Context, account *Account) error
        DeleteAccount(ctx context.Context, id uuid.UUID) error
}

// repository implements the Repository interface
type repository struct {
        db *gorm.DB
}

// NewRepository creates a new transaction repository
func NewRepository(db *gorm.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Transaction operations

// CreateTransaction creates a new transaction
func (r *repository) CreateTransaction(ctx context.Context, transaction *Transaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(transaction).Error
}</span>

// GetTransactionByID retrieves a transaction by ID
func (r *repository) GetTransactionByID(ctx context.Context, id uuid.UUID) (*Transaction, error) <span class="cov0" title="0">{
        var transaction Transaction
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;transaction).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrTransactionNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;transaction, nil</span>
}

// GetTransactionsByUser retrieves transactions for a user with pagination
func (r *repository) GetTransactionsByUser(ctx context.Context, userID uuid.UUID, offset, limit int) ([]Transaction, error) <span class="cov0" title="0">{
        var transactions []Transaction
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("transaction_date DESC, created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;transactions).Error
        return transactions, err
}</span>

// GetTransactionsByAccount retrieves transactions for an account with pagination
func (r *repository) GetTransactionsByAccount(ctx context.Context, accountID uuid.UUID, offset, limit int) ([]Transaction, error) <span class="cov0" title="0">{
        var transactions []Transaction
        err := r.db.WithContext(ctx).
                Where("account_id = ?", accountID).
                Order("transaction_date DESC, created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;transactions).Error
        return transactions, err
}</span>

// UpdateTransaction updates a transaction
func (r *repository) UpdateTransaction(ctx context.Context, transaction *Transaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(transaction).Error
}</span>

// DeleteTransaction deletes a transaction
func (r *repository) DeleteTransaction(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;Transaction{}, id).Error
}</span>

// Category operations

// CreateCategory creates a new category
func (r *repository) CreateCategory(ctx context.Context, category *Category) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(category).Error
}</span>

// GetCategoryByID retrieves a category by ID
func (r *repository) GetCategoryByID(ctx context.Context, id uuid.UUID) (*Category, error) <span class="cov0" title="0">{
        var category Category
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;category).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrCategoryNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;category, nil</span>
}

// GetCategories retrieves all categories with pagination
func (r *repository) GetCategories(ctx context.Context, offset, limit int) ([]Category, error) <span class="cov0" title="0">{
        var categories []Category
        err := r.db.WithContext(ctx).
                Order("sort_order ASC, name ASC").
                Offset(offset).
                Limit(limit).
                Find(&amp;categories).Error
        return categories, err
}</span>

// GetDefaultCategories retrieves default categories
func (r *repository) GetDefaultCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        var categories []Category
        err := r.db.WithContext(ctx).
                Where("is_default = ?", true).
                Order("sort_order ASC, name ASC").
                Find(&amp;categories).Error
        return categories, err
}</span>

// UpdateCategory updates a category
func (r *repository) UpdateCategory(ctx context.Context, category *Category) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(category).Error
}</span>

// DeleteCategory deletes a category
func (r *repository) DeleteCategory(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;Category{}, id).Error
}</span>

// Account operations

// CreateAccount creates a new account
func (r *repository) CreateAccount(ctx context.Context, account *Account) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(account).Error
}</span>

// GetAccountByID retrieves an account by ID
func (r *repository) GetAccountByID(ctx context.Context, id uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        var account Account
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;account).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrAccountNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;account, nil</span>
}

// GetAccountsByUser retrieves all accounts for a user
func (r *repository) GetAccountsByUser(ctx context.Context, userID uuid.UUID) ([]Account, error) <span class="cov0" title="0">{
        var accounts []Account
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("name ASC").
                Find(&amp;accounts).Error
        return accounts, err
}</span>

// UpdateAccount updates an account
func (r *repository) UpdateAccount(ctx context.Context, account *Account) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(account).Error
}</span>

// DeleteAccount deletes an account
func (r *repository) DeleteAccount(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;Account{}, id).Error
}</span>

// Custom errors
var (
        ErrTransactionNotFound = errors.New("transaction not found")
        ErrCategoryNotFound    = errors.New("category not found")
        ErrAccountNotFound     = errors.New("account not found")
)
</pre>
		
		<pre class="file" id="file9" style="display: none">package transaction

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// Service defines the interface for transaction business logic
type Service interface {
        // Transaction operations
        CreateTransaction(ctx context.Context, userID uuid.UUID, req *CreateTransactionRequest) (*TransactionResponse, error)
        GetTransaction(ctx context.Context, userID, transactionID uuid.UUID) (*TransactionResponse, error)
        GetTransactions(ctx context.Context, userID uuid.UUID, offset, limit int) ([]TransactionResponse, error)
        UpdateTransaction(ctx context.Context, userID, transactionID uuid.UUID, req *UpdateTransactionRequest) (*TransactionResponse, error)
        DeleteTransaction(ctx context.Context, userID, transactionID uuid.UUID) error

        // Category operations
        CreateCategory(ctx context.Context, req *CreateCategoryRequest) (*Category, error)
        GetCategory(ctx context.Context, categoryID uuid.UUID) (*Category, error)
        GetCategories(ctx context.Context, offset, limit int) ([]Category, error)
        GetDefaultCategories(ctx context.Context) ([]Category, error)
        UpdateCategory(ctx context.Context, categoryID uuid.UUID, req *CreateCategoryRequest) (*Category, error)
        DeleteCategory(ctx context.Context, categoryID uuid.UUID) error

        // Account operations
        CreateAccount(ctx context.Context, userID uuid.UUID, req *CreateAccountRequest) (*Account, error)
        GetAccount(ctx context.Context, userID, accountID uuid.UUID) (*Account, error)
        GetAccounts(ctx context.Context, userID uuid.UUID) ([]Account, error)
        UpdateAccount(ctx context.Context, userID, accountID uuid.UUID, req *CreateAccountRequest) (*Account, error)
        DeleteAccount(ctx context.Context, userID, accountID uuid.UUID) error
}

// service implements the Service interface
type service struct {
        repo Repository
}

// NewService creates a new transaction service
func NewService(repo Repository) Service <span class="cov5" title="2">{
        return &amp;service{repo: repo}
}</span>

// Transaction operations

// CreateTransaction creates a new transaction
func (s *service) CreateTransaction(ctx context.Context, userID uuid.UUID, req *CreateTransactionRequest) (*TransactionResponse, error) <span class="cov5" title="2">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "CreateTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", req.AccountID.String()),
                        attribute.Float64("amount", req.Amount),
                ),
        )
        defer span.End()

        // Validate amount
        if req.Amount == 0 </span><span class="cov0" title="0">{
                span.RecordError(errors.New("amount cannot be zero"))
                span.SetStatus(codes.Error, "amount cannot be zero")
                return nil, errors.New("amount cannot be zero")
        }</span>

        // Validate account exists and belongs to user
        <span class="cov5" title="2">account, err := s.repo.GetAccountByID(ctx, req.AccountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return nil, fmt.Errorf("failed to get account: %w", err)
        }</span>

        <span class="cov5" title="2">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return nil, errors.New("account does not belong to user")
        }</span>

        // Validate category if provided
        <span class="cov5" title="2">if req.CategoryID != nil </span><span class="cov0" title="0">{
                _, err := s.repo.GetCategoryByID(ctx, *req.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to get category")
                        return nil, fmt.Errorf("failed to get category: %w", err)
                }</span>
        }

        // Set default currency if not provided
        <span class="cov5" title="2">if req.Currency == "" </span><span class="cov0" title="0">{
                req.Currency = "USD"
        }</span>

        // Create transaction
        <span class="cov5" title="2">transaction := &amp;Transaction{
                UserID:          userID,
                AccountID:       req.AccountID,
                CategoryID:      req.CategoryID,
                Amount:          req.Amount,
                Currency:        req.Currency,
                Description:     req.Description,
                Merchant:        req.Merchant,
                Location:        req.Location,
                TransactionDate: req.TransactionDate,
                PostedDate:      req.PostedDate,
                Status:          TransactionStatusPending,
                Tags:            req.Tags,
                Notes:           req.Notes,
        }

        if err := s.repo.CreateTransaction(ctx, transaction); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create transaction")
                return nil, fmt.Errorf("failed to create transaction: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction created successfully")
        return s.toTransactionResponse(transaction), nil</span>
}

// GetTransaction retrieves a transaction by ID
func (s *service) GetTransaction(ctx context.Context, userID, transactionID uuid.UUID) (*TransactionResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("transaction_id", transactionID.String()),
                ),
        )
        defer span.End()

        transaction, err := s.repo.GetTransactionByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transaction")
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>

        // Check if transaction belongs to user
        <span class="cov1" title="1">if transaction.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("transaction does not belong to user"))
                span.SetStatus(codes.Error, "transaction does not belong to user")
                return nil, errors.New("transaction does not belong to user")
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction retrieved successfully")
        return s.toTransactionResponse(transaction), nil</span>
}

// GetTransactions retrieves transactions for a user with pagination
func (s *service) GetTransactions(ctx context.Context, userID uuid.UUID, offset, limit int) ([]TransactionResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetTransactions",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.Int("offset", offset),
                        attribute.Int("limit", limit),
                ),
        )
        defer span.End()

        // Set default limit if not provided
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov1" title="1">transactions, err := s.repo.GetTransactionsByUser(ctx, userID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transactions")
                return nil, fmt.Errorf("failed to get transactions: %w", err)
        }</span>

        <span class="cov1" title="1">responses := make([]TransactionResponse, len(transactions))
        for i, transaction := range transactions </span><span class="cov1" title="1">{
                responses[i] = *s.toTransactionResponse(&amp;transaction)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transactions retrieved successfully")
        return responses, nil</span>
}

// UpdateTransaction updates a transaction
func (s *service) UpdateTransaction(ctx context.Context, userID, transactionID uuid.UUID, req *UpdateTransactionRequest) (*TransactionResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "UpdateTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("transaction_id", transactionID.String()),
                ),
        )
        defer span.End()

        transaction, err := s.repo.GetTransactionByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transaction")
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>

        // Check if transaction belongs to user
        <span class="cov1" title="1">if transaction.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("transaction does not belong to user"))
                span.SetStatus(codes.Error, "transaction does not belong to user")
                return nil, errors.New("transaction does not belong to user")
        }</span>

        // Update fields if provided
        <span class="cov1" title="1">if req.CategoryID != nil </span><span class="cov0" title="0">{
                // Validate category exists
                _, err := s.repo.GetCategoryByID(ctx, *req.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to get category")
                        return nil, fmt.Errorf("failed to get category: %w", err)
                }</span>
                <span class="cov0" title="0">transaction.CategoryID = req.CategoryID</span>
        }

        <span class="cov1" title="1">if req.Amount != nil </span><span class="cov0" title="0">{
                if *req.Amount == 0 </span><span class="cov0" title="0">{
                        span.RecordError(errors.New("amount cannot be zero"))
                        span.SetStatus(codes.Error, "amount cannot be zero")
                        return nil, errors.New("amount cannot be zero")
                }</span>
                <span class="cov0" title="0">transaction.Amount = *req.Amount</span>
        }

        <span class="cov1" title="1">if req.Currency != "" </span><span class="cov0" title="0">{
                transaction.Currency = req.Currency
        }</span>

        <span class="cov1" title="1">if req.Description != "" </span><span class="cov1" title="1">{
                transaction.Description = req.Description
        }</span>

        <span class="cov1" title="1">if req.Merchant != "" </span><span class="cov0" title="0">{
                transaction.Merchant = req.Merchant
        }</span>

        <span class="cov1" title="1">if req.Location != "" </span><span class="cov0" title="0">{
                transaction.Location = req.Location
        }</span>

        <span class="cov1" title="1">if req.TransactionDate != nil </span><span class="cov0" title="0">{
                transaction.TransactionDate = *req.TransactionDate
        }</span>

        <span class="cov1" title="1">if req.PostedDate != nil </span><span class="cov0" title="0">{
                transaction.PostedDate = req.PostedDate
        }</span>

        <span class="cov1" title="1">if req.Status != nil </span><span class="cov0" title="0">{
                transaction.Status = *req.Status
        }</span>

        <span class="cov1" title="1">if req.Tags != nil </span><span class="cov0" title="0">{
                transaction.Tags = req.Tags
        }</span>

        <span class="cov1" title="1">if req.Notes != "" </span><span class="cov0" title="0">{
                transaction.Notes = req.Notes
        }</span>

        <span class="cov1" title="1">transaction.UpdatedAt = time.Now()

        if err := s.repo.UpdateTransaction(ctx, transaction); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to update transaction")
                return nil, fmt.Errorf("failed to update transaction: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction updated successfully")
        return s.toTransactionResponse(transaction), nil</span>
}

// DeleteTransaction deletes a transaction
func (s *service) DeleteTransaction(ctx context.Context, userID, transactionID uuid.UUID) error <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "DeleteTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("transaction_id", transactionID.String()),
                ),
        )
        defer span.End()

        transaction, err := s.repo.GetTransactionByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transaction")
                return fmt.Errorf("failed to get transaction: %w", err)
        }</span>

        // Check if transaction belongs to user
        <span class="cov1" title="1">if transaction.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("transaction does not belong to user"))
                span.SetStatus(codes.Error, "transaction does not belong to user")
                return errors.New("transaction does not belong to user")
        }</span>

        <span class="cov1" title="1">if err := s.repo.DeleteTransaction(ctx, transactionID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to delete transaction")
                return fmt.Errorf("failed to delete transaction: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction deleted successfully")
        return nil</span>
}

// Category operations

// CreateCategory creates a new category
func (s *service) CreateCategory(ctx context.Context, req *CreateCategoryRequest) (*Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "CreateCategory",
                trace.WithAttributes(
                        attribute.String("name", req.Name),
                ),
        )
        defer span.End()

        category := &amp;Category{
                Name:        req.Name,
                Description: req.Description,
                Icon:        req.Icon,
                Color:       req.Color,
                ParentID:    req.ParentID,
                IsDefault:   req.IsDefault,
                SortOrder:   req.SortOrder,
        }

        if err := s.repo.CreateCategory(ctx, category); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create category")
                return nil, fmt.Errorf("failed to create category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category created successfully")
        return category, nil</span>
}

// GetCategory retrieves a category by ID
func (s *service) GetCategory(ctx context.Context, categoryID uuid.UUID) (*Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetCategory",
                trace.WithAttributes(
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        category, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get category")
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category retrieved successfully")
        return category, nil</span>
}

// GetCategories retrieves all categories with pagination
func (s *service) GetCategories(ctx context.Context, offset, limit int) ([]Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetCategories",
                trace.WithAttributes(
                        attribute.Int("offset", offset),
                        attribute.Int("limit", limit),
                ),
        )
        defer span.End()

        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">categories, err := s.repo.GetCategories(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get categories")
                return nil, fmt.Errorf("failed to get categories: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "categories retrieved successfully")
        return categories, nil</span>
}

// GetDefaultCategories retrieves default categories
func (s *service) GetDefaultCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetDefaultCategories")
        defer span.End()

        categories, err := s.repo.GetDefaultCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get default categories")
                return nil, fmt.Errorf("failed to get default categories: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "default categories retrieved successfully")
        return categories, nil</span>
}

// UpdateCategory updates a category
func (s *service) UpdateCategory(ctx context.Context, categoryID uuid.UUID, req *CreateCategoryRequest) (*Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "UpdateCategory",
                trace.WithAttributes(
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        category, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get category")
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>

        // Update fields
        <span class="cov0" title="0">category.Name = req.Name
        category.Description = req.Description
        category.Icon = req.Icon
        category.Color = req.Color
        category.ParentID = req.ParentID
        category.IsDefault = req.IsDefault
        category.SortOrder = req.SortOrder
        category.UpdatedAt = time.Now()

        if err := s.repo.UpdateCategory(ctx, category); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to update category")
                return nil, fmt.Errorf("failed to update category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category updated successfully")
        return category, nil</span>
}

// DeleteCategory deletes a category
func (s *service) DeleteCategory(ctx context.Context, categoryID uuid.UUID) error <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "DeleteCategory",
                trace.WithAttributes(
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        if err := s.repo.DeleteCategory(ctx, categoryID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to delete category")
                return fmt.Errorf("failed to delete category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category deleted successfully")
        return nil</span>
}

// Account operations

// CreateAccount creates a new account
func (s *service) CreateAccount(ctx context.Context, userID uuid.UUID, req *CreateAccountRequest) (*Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "CreateAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("name", req.Name),
                        attribute.String("type", string(req.Type)),
                ),
        )
        defer span.End()

        // Set default currency if not provided
        if req.Currency == "" </span><span class="cov0" title="0">{
                req.Currency = "USD"
        }</span>

        <span class="cov0" title="0">account := &amp;Account{
                UserID:            userID,
                Name:              req.Name,
                Type:              req.Type,
                Institution:       req.Institution,
                AccountNumberHash: req.AccountNumberHash,
                Balance:           req.Balance,
                Currency:          req.Currency,
                PlaidAccountID:    req.PlaidAccountID,
        }

        if err := s.repo.CreateAccount(ctx, account); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create account")
                return nil, fmt.Errorf("failed to create account: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account created successfully")
        return account, nil</span>
}

// GetAccount retrieves an account by ID
func (s *service) GetAccount(ctx context.Context, userID, accountID uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", accountID.String()),
                ),
        )
        defer span.End()

        account, err := s.repo.GetAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return nil, fmt.Errorf("failed to get account: %w", err)
        }</span>

        // Check if account belongs to user
        <span class="cov0" title="0">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return nil, errors.New("account does not belong to user")
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account retrieved successfully")
        return account, nil</span>
}

// GetAccounts retrieves all accounts for a user
func (s *service) GetAccounts(ctx context.Context, userID uuid.UUID) ([]Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetAccounts",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                ),
        )
        defer span.End()

        accounts, err := s.repo.GetAccountsByUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get accounts")
                return nil, fmt.Errorf("failed to get accounts: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "accounts retrieved successfully")
        return accounts, nil</span>
}

// UpdateAccount updates an account
func (s *service) UpdateAccount(ctx context.Context, userID, accountID uuid.UUID, req *CreateAccountRequest) (*Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "UpdateAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", accountID.String()),
                ),
        )
        defer span.End()

        account, err := s.repo.GetAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return nil, fmt.Errorf("failed to get account: %w", err)
        }</span>

        // Check if account belongs to user
        <span class="cov0" title="0">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return nil, errors.New("account does not belong to user")
        }</span>

        // Update fields
        <span class="cov0" title="0">account.Name = req.Name
        account.Type = req.Type
        account.Institution = req.Institution
        account.AccountNumberHash = req.AccountNumberHash
        account.Balance = req.Balance
        account.Currency = req.Currency
        account.PlaidAccountID = req.PlaidAccountID
        account.UpdatedAt = time.Now()

        if err := s.repo.UpdateAccount(ctx, account); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to update account")
                return nil, fmt.Errorf("failed to update account: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account updated successfully")
        return account, nil</span>
}

// DeleteAccount deletes an account
func (s *service) DeleteAccount(ctx context.Context, userID, accountID uuid.UUID) error <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "DeleteAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", accountID.String()),
                ),
        )
        defer span.End()

        account, err := s.repo.GetAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return fmt.Errorf("failed to get account: %w", err)
        }</span>

        // Check if account belongs to user
        <span class="cov0" title="0">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return errors.New("account does not belong to user")
        }</span>

        <span class="cov0" title="0">if err := s.repo.DeleteAccount(ctx, accountID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to delete account")
                return fmt.Errorf("failed to delete account: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account deleted successfully")
        return nil</span>
}

// Helper methods

// toTransactionResponse converts a Transaction to TransactionResponse
func (s *service) toTransactionResponse(transaction *Transaction) *TransactionResponse <span class="cov10" title="4">{
        return &amp;TransactionResponse{
                ID:                       transaction.ID,
                UserID:                   transaction.UserID,
                FamilyID:                 transaction.FamilyID,
                AccountID:                transaction.AccountID,
                CategoryID:               transaction.CategoryID,
                Amount:                   transaction.Amount,
                Currency:                 transaction.Currency,
                Description:              transaction.Description,
                Merchant:                 transaction.Merchant,
                Location:                 transaction.Location,
                TransactionDate:          transaction.TransactionDate,
                PostedDate:               transaction.PostedDate,
                Status:                   transaction.Status,
                CategorizationSource:     transaction.CategorizationSource,
                CategorizationConfidence: transaction.CategorizationConfidence,
                Tags:                     transaction.Tags,
                Notes:                    transaction.Notes,
                ReceiptURL:               transaction.ReceiptURL,
                CreatedAt:                transaction.CreatedAt,
                UpdatedAt:                transaction.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package user

import (
        "time"

        "github.com/google/uuid"
)

// User represents a user in the system
type User struct {
        ID               uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Email            string     `json:"email" gorm:"unique;not null"`
        PasswordHash     string     `json:"-" gorm:"not null"`
        FirstName        string     `json:"first_name"`
        LastName         string     `json:"last_name"`
        Phone            string     `json:"phone"`
        DateOfBirth      *time.Time `json:"date_of_birth"`
        Timezone         string     `json:"timezone" gorm:"default:'UTC'"`
        Locale           string     `json:"locale" gorm:"default:'en-US'"`
        Role             UserRole   `json:"role" gorm:"default:'user'"`
        Status           UserStatus `json:"status" gorm:"default:'active'"`
        EmailVerified    bool       `json:"email_verified" gorm:"default:false"`
        PhoneVerified    bool       `json:"phone_verified" gorm:"default:false"`
        TwoFactorEnabled bool       `json:"two_factor_enabled" gorm:"default:false"`
        LastLoginAt      *time.Time `json:"last_login_at"`
        CreatedAt        time.Time  `json:"created_at"`
        UpdatedAt        time.Time  `json:"updated_at"`
}

// UserRole represents the role of a user
type UserRole string

const (
        UserRoleUser         UserRole = "user"
        UserRolePremium      UserRole = "premium"
        UserRoleAdmin        UserRole = "admin"
        UserRoleFamilyOwner  UserRole = "family_owner"
        UserRoleFamilyMember UserRole = "family_member"
)

// UserStatus represents the status of a user
type UserStatus string

const (
        UserStatusActive    UserStatus = "active"
        UserStatusInactive  UserStatus = "inactive"
        UserStatusSuspended UserStatus = "suspended"
        UserStatusDeleted   UserStatus = "deleted"
)

// DeviceInfo represents device information for a session
type DeviceInfo struct {
        DeviceType string `json:"device_type,omitempty"`
        OS         string `json:"os,omitempty"`
        Browser    string `json:"browser,omitempty"`
        DeviceID   string `json:"device_id,omitempty"`
        AppVersion string `json:"app_version,omitempty"`
}

// UserSession represents a user session
type UserSession struct {
        ID              uuid.UUID   `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID          uuid.UUID   `json:"user_id" gorm:"type:uuid;not null"`
        RefreshToken    string      `json:"refresh_token" gorm:"unique;not null"`
        AccessTokenHash string      `json:"access_token_hash"`
        DeviceInfo      *DeviceInfo `json:"device_info" gorm:"type:jsonb"`
        IPAddress       string      `json:"ip_address"`
        UserAgent       string      `json:"user_agent"`
        ExpiresAt       time.Time   `json:"expires_at" gorm:"not null"`
        RevokedAt       *time.Time  `json:"revoked_at"`
        CreatedAt       time.Time   `json:"created_at"`
}

// CreateUserRequest represents a request to create a new user
type CreateUserRequest struct {
        Email     string `json:"email" binding:"required,email"`
        Password  string `json:"password" binding:"required,min=8"`
        FirstName string `json:"first_name" binding:"required"`
        LastName  string `json:"last_name" binding:"required"`
        Phone     string `json:"phone"`
        Timezone  string `json:"timezone"`
        Locale    string `json:"locale"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

// UpdateUserRequest represents a request to update a user
type UpdateUserRequest struct {
        FirstName   string     `json:"first_name"`
        LastName    string     `json:"last_name"`
        Phone       string     `json:"phone"`
        DateOfBirth *time.Time `json:"date_of_birth"`
        Timezone    string     `json:"timezone"`
        Locale      string     `json:"locale"`
}

// UserResponse represents a user response
type UserResponse struct {
        ID            uuid.UUID  `json:"id"`
        Email         string     `json:"email"`
        FirstName     string     `json:"first_name"`
        LastName      string     `json:"last_name"`
        Phone         string     `json:"phone"`
        DateOfBirth   *time.Time `json:"date_of_birth"`
        Timezone      string     `json:"timezone"`
        Locale        string     `json:"locale"`
        Role          UserRole   `json:"role"`
        Status        UserStatus `json:"status"`
        EmailVerified bool       `json:"email_verified"`
        PhoneVerified bool       `json:"phone_verified"`
        LastLoginAt   *time.Time `json:"last_login_at"`
        CreatedAt     time.Time  `json:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at"`
}

// TableName specifies the table name for User
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

// TableName specifies the table name for UserSession
func (UserSession) TableName() string <span class="cov0" title="0">{
        return "user_sessions"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package user

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository defines the interface for user data operations
type Repository interface {
        Create(ctx context.Context, user *User) error
        GetByID(ctx context.Context, id uuid.UUID) (*User, error)
        GetByEmail(ctx context.Context, email string) (*User, error)
        Update(ctx context.Context, user *User) error
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, offset, limit int) ([]User, error)
        CreateSession(ctx context.Context, session *UserSession) error
        GetSessionByRefreshToken(ctx context.Context, refreshToken string) (*UserSession, error)
        RevokeSession(ctx context.Context, sessionID uuid.UUID) error
        RevokeAllUserSessions(ctx context.Context, userID uuid.UUID) error
}

// repository implements the Repository interface
type repository struct {
        db *gorm.DB
}

// NewRepository creates a new user repository
func NewRepository(db *gorm.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Create creates a new user
func (r *repository) Create(ctx context.Context, user *User) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(user).Error
}</span>

// GetByID retrieves a user by ID
func (r *repository) GetByID(ctx context.Context, id uuid.UUID) (*User, error) <span class="cov0" title="0">{
        var user User
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetByEmail retrieves a user by email
func (r *repository) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{
        var user User
        err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// Update updates a user
func (r *repository) Update(ctx context.Context, user *User) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(user).Error
}</span>

// Delete deletes a user
func (r *repository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;User{}, id).Error
}</span>

// List retrieves a list of users with pagination
func (r *repository) List(ctx context.Context, offset, limit int) ([]User, error) <span class="cov0" title="0">{
        var users []User
        err := r.db.WithContext(ctx).Offset(offset).Limit(limit).Find(&amp;users).Error
        return users, err
}</span>

// CreateSession creates a new user session
func (r *repository) CreateSession(ctx context.Context, session *UserSession) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(session).Error
}</span>

// GetSessionByRefreshToken retrieves a session by refresh token
func (r *repository) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (*UserSession, error) <span class="cov0" title="0">{
        var session UserSession
        err := r.db.WithContext(ctx).Where("refresh_token = ? AND revoked_at IS NULL", refreshToken).First(&amp;session).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrSessionNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;session, nil</span>
}

// RevokeSession revokes a specific session
func (r *repository) RevokeSession(ctx context.Context, sessionID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;UserSession{}).Where("id = ?", sessionID).Update("revoked_at", gorm.Expr("NOW()")).Error
}</span>

// RevokeAllUserSessions revokes all sessions for a user
func (r *repository) RevokeAllUserSessions(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;UserSession{}).Where("user_id = ?", userID).Update("revoked_at", gorm.Expr("NOW()")).Error
}</span>

// Custom errors
var (
        ErrUserNotFound    = errors.New("user not found")
        ErrSessionNotFound = errors.New("session not found")
)
</pre>
		
		<pre class="file" id="file12" style="display: none">package user

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "errors"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// Service defines the interface for user business logic
type Service interface {
        Register(ctx context.Context, req *CreateUserRequest) (*UserResponse, error)
        Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error)
        GetProfile(ctx context.Context, userID uuid.UUID) (*UserResponse, error)
        UpdateProfile(ctx context.Context, userID uuid.UUID, req *UpdateUserRequest) (*UserResponse, error)
        RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error)
        Logout(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error
        ValidateToken(ctx context.Context, tokenString string) (*Claims, error)
}

// service implements the Service interface
type service struct {
        repo          Repository
        jwtSecret     string
        tokenExpiry   time.Duration
        refreshExpiry time.Duration
}

// NewService creates a new user service
func NewService(repo Repository, jwtSecret string) Service <span class="cov10" title="10">{
        return &amp;service{
                repo:          repo,
                jwtSecret:     jwtSecret,
                tokenExpiry:   15 * time.Minute,
                refreshExpiry: 7 * 24 * time.Hour, // 7 days
        }
}</span>

// Claims represents JWT claims
type Claims struct {
        UserID uuid.UUID `json:"user_id"`
        Email  string    `json:"email"`
        Role   UserRole  `json:"role"`
        jwt.RegisteredClaims
}

// LoginResponse represents a login response
type LoginResponse struct {
        User         *UserResponse `json:"user"`
        AccessToken  string        `json:"access_token"`
        RefreshToken string        `json:"refresh_token"`
        ExpiresIn    int64         `json:"expires_in"`
}

// Register creates a new user account
func (s *service) Register(ctx context.Context, req *CreateUserRequest) (*UserResponse, error) <span class="cov5" title="3">{
        // Check if user already exists
        existingUser, err := s.repo.GetByEmail(ctx, req.Email)
        if err != nil &amp;&amp; !errors.Is(err, ErrUserNotFound) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>
        <span class="cov3" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                return nil, ErrUserAlreadyExists
        }</span>

        // Hash password
        <span class="cov1" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Create user
        <span class="cov1" title="1">user := &amp;User{
                ID:           uuid.New(),
                Email:        req.Email,
                PasswordHash: string(hashedPassword),
                FirstName:    req.FirstName,
                LastName:     req.LastName,
                Phone:        req.Phone,
                Timezone:     req.Timezone,
                Locale:       req.Locale,
                Role:         UserRoleUser,
                Status:       UserStatusActive,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := s.repo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov1" title="1">return s.toUserResponse(user), nil</span>
}

// Login authenticates a user and returns tokens
func (s *service) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov5" title="3">{
        // Get user by email
        user, err := s.repo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, ErrUserNotFound) </span><span class="cov1" title="1">{
                        return nil, ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        // Check if user is active
        <span class="cov3" title="2">if user.Status != UserStatusActive </span><span class="cov1" title="1">{
                return nil, ErrUserInactive
        }</span>

        // Verify password
        <span class="cov1" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        // Update last login
        <span class="cov1" title="1">user.LastLoginAt = &amp;time.Time{}
        *user.LastLoginAt = time.Now()
        if err := s.repo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update last login: %w", err)
        }</span>

        // Generate tokens
        <span class="cov1" title="1">accessToken, err := s.generateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov1" title="1">refreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Create session
        <span class="cov1" title="1">session := &amp;UserSession{
                ID:           uuid.New(),
                UserID:       user.ID,
                RefreshToken: refreshToken,
                DeviceInfo:   nil, // Explicitly set to nil for JSONB field
                ExpiresAt:    time.Now().Add(s.refreshExpiry),
                CreatedAt:    time.Now(),
        }

        if err := s.repo.CreateSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;LoginResponse{
                User:         s.toUserResponse(user),
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(s.tokenExpiry.Seconds()),
        }, nil</span>
}

// GetProfile retrieves user profile
func (s *service) GetProfile(ctx context.Context, userID uuid.UUID) (*UserResponse, error) <span class="cov3" title="2">{
        user, err := s.repo.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return s.toUserResponse(user), nil</span>
}

// UpdateProfile updates user profile
func (s *service) UpdateProfile(ctx context.Context, userID uuid.UUID, req *UpdateUserRequest) (*UserResponse, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.FirstName != "" </span><span class="cov0" title="0">{
                user.FirstName = req.FirstName
        }</span>
        <span class="cov0" title="0">if req.LastName != "" </span><span class="cov0" title="0">{
                user.LastName = req.LastName
        }</span>
        <span class="cov0" title="0">if req.Phone != "" </span><span class="cov0" title="0">{
                user.Phone = req.Phone
        }</span>
        <span class="cov0" title="0">if req.DateOfBirth != nil </span><span class="cov0" title="0">{
                user.DateOfBirth = req.DateOfBirth
        }</span>
        <span class="cov0" title="0">if req.Timezone != "" </span><span class="cov0" title="0">{
                user.Timezone = req.Timezone
        }</span>
        <span class="cov0" title="0">if req.Locale != "" </span><span class="cov0" title="0">{
                user.Locale = req.Locale
        }</span>

        <span class="cov0" title="0">user.UpdatedAt = time.Now()

        if err := s.repo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return s.toUserResponse(user), nil</span>
}

// RefreshToken refreshes access token using refresh token
func (s *service) RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error) <span class="cov0" title="0">{
        // Get session by refresh token
        session, err := s.repo.GetSessionByRefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        // Check if session is expired
        <span class="cov0" title="0">if time.Now().After(session.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, ErrRefreshTokenExpired
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.repo.GetByID(ctx, session.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate new access token
        <span class="cov0" title="0">accessToken, err := s.generateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;LoginResponse{
                User:         s.toUserResponse(user),
                AccessToken:  accessToken,
                RefreshToken: refreshToken, // Return same refresh token
                ExpiresIn:    int64(s.tokenExpiry.Seconds()),
        }, nil</span>
}

// Logout logs out a user by revoking their session
func (s *service) Logout(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error <span class="cov0" title="0">{
        return s.repo.RevokeSession(ctx, sessionID)
}</span>

// ValidateToken validates and parses JWT token
func (s *service) ValidateToken(ctx context.Context, tokenString string) (*Claims, error) <span class="cov3" title="2">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(s.jwtSecret), nil</span>
        })

        <span class="cov3" title="2">if err != nil </span><span class="cov3" title="2">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, ErrInvalidToken</span>
}

// generateAccessToken generates a JWT access token
func (s *service) generateAccessToken(user *User) (string, error) <span class="cov3" title="2">{
        claims := &amp;Claims{
                UserID: user.ID,
                Email:  user.Email,
                Role:   user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(s.tokenExpiry)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "fiscaflow",
                        Subject:   user.ID.String(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>

// generateRefreshToken generates a secure refresh token
func (s *service) generateRefreshToken() (string, error) <span class="cov3" title="2">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="2">return hex.EncodeToString(bytes), nil</span>
}

// toUserResponse converts User to UserResponse
func (s *service) toUserResponse(user *User) *UserResponse <span class="cov5" title="3">{
        return &amp;UserResponse{
                ID:            user.ID,
                Email:         user.Email,
                FirstName:     user.FirstName,
                LastName:      user.LastName,
                Phone:         user.Phone,
                DateOfBirth:   user.DateOfBirth,
                Timezone:      user.Timezone,
                Locale:        user.Locale,
                Role:          user.Role,
                Status:        user.Status,
                EmailVerified: user.EmailVerified,
                PhoneVerified: user.PhoneVerified,
                LastLoginAt:   user.LastLoginAt,
                CreatedAt:     user.CreatedAt,
                UpdatedAt:     user.UpdatedAt,
        }
}</span>

// Custom errors
var (
        ErrUserAlreadyExists   = errors.New("user already exists")
        ErrInvalidCredentials  = errors.New("invalid credentials")
        ErrUserInactive        = errors.New("user account is inactive")
        ErrInvalidRefreshToken = errors.New("invalid refresh token")
        ErrRefreshTokenExpired = errors.New("refresh token expired")
        ErrInvalidToken        = errors.New("invalid token")
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "fiscaflow/internal/domain/transaction"
        "fiscaflow/internal/domain/user"
)

// Config represents database configuration
type Config struct {
        Host            string
        Port            int
        User            string
        Password        string
        DBName          string
        SSLMode         string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
}

// Database represents the database connection
type Database struct {
        DB *gorm.DB
}

// NewDatabase creates a new database connection
func NewDatabase(config *Config) (*Database, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(config.MaxOpenConns)
        sqlDB.SetMaxIdleConns(config.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)

        return &amp;Database{DB: db}, nil</span>
}

// AutoMigrate runs database migrations
func (d *Database) AutoMigrate() error <span class="cov0" title="0">{
        return d.DB.AutoMigrate(
                &amp;user.User{},
                &amp;user.UserSession{},
                &amp;transaction.Transaction{},
                &amp;transaction.Category{},
                &amp;transaction.Account{},
        )
}</span>

// Ping checks database connectivity
func (d *Database) Ping(ctx context.Context) error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov0" title="0">return sqlDB.PingContext(ctx)</span>
}

// Close closes the database connection
func (d *Database) Close() error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov0" title="0">return sqlDB.Close()</span>
}

// GetDB returns the underlying GORM DB instance
func (d *Database) GetDB() *gorm.DB <span class="cov0" title="0">{
        return d.DB
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package logging

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewLogger creates a new configured logger
func NewLogger() *zap.Logger <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        config.EncoderConfig.TimeKey = "timestamp"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        config.EncoderConfig.StacktraceKey = "stacktrace"
        config.EncoderConfig.MessageKey = "message"
        config.EncoderConfig.LevelKey = "level"
        config.EncoderConfig.CallerKey = "caller"

        logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize logger: " + err.Error())</span>
        }

        <span class="cov0" title="0">return logger</span>
}

// GinLogger returns a gin.HandlerFunc for logging HTTP requests
func GinLogger(logger *zap.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                logger.Info("HTTP Request",
                        zap.String("method", param.Method),
                        zap.String("path", param.Path),
                        zap.Int("status", param.StatusCode),
                        zap.Duration("latency", param.Latency),
                        zap.String("client_ip", param.ClientIP),
                        zap.String("user_agent", param.Request.UserAgent()),
                        zap.Time("timestamp", param.TimeStamp),
                )
                return ""
        }</span>)
}

// WithTraceID adds trace ID to logger context
func WithTraceID(logger *zap.Logger, traceID string) *zap.Logger <span class="cov0" title="0">{
        return logger.With(zap.String("trace_id", traceID))
}</span>

// WithUserID adds user ID to logger context
func WithUserID(logger *zap.Logger, userID string) *zap.Logger <span class="cov0" title="0">{
        return logger.With(zap.String("user_id", userID))
}</span>

// WithRequestID adds request ID to logger context
func WithRequestID(logger *zap.Logger, requestID string) *zap.Logger <span class="cov0" title="0">{
        return logger.With(zap.String("request_id", requestID))
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package tracing

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// InitTracer initializes OpenTelemetry tracer
func InitTracer(endpoint string) (*sdktrace.TracerProvider, error) <span class="cov0" title="0">{
        // Create OTLP gRPC exporter
        client := otlptracegrpc.NewClient(
                otlptracegrpc.WithEndpoint(endpoint),
                otlptracegrpc.WithInsecure(),
        )
        exporter, err := otlptrace.New(context.Background(), client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        }</span>

        // Create resource
        <span class="cov0" title="0">res, err := resource.New(context.Background(),
                resource.WithAttributes(
                        semconv.ServiceName("fiscaflow"),
                        semconv.ServiceVersion("1.0.0"),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Create tracer provider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
        )

        return tp, nil</span>
}

// ShutdownTracer gracefully shuts down the tracer
func ShutdownTracer(tp *sdktrace.TracerProvider, ctx context.Context) error <span class="cov0" title="0">{
        return tp.Shutdown(ctx)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
