
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">fiscaflow/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">fiscaflow/internal/api/handlers/account.go (54.9%)</option>
				
				<option value="file2">fiscaflow/internal/api/handlers/analytics.go (61.3%)</option>
				
				<option value="file3">fiscaflow/internal/api/handlers/budget.go (30.5%)</option>
				
				<option value="file4">fiscaflow/internal/api/handlers/category.go (59.0%)</option>
				
				<option value="file5">fiscaflow/internal/api/handlers/transaction.go (15.7%)</option>
				
				<option value="file6">fiscaflow/internal/api/handlers/user.go (39.2%)</option>
				
				<option value="file7">fiscaflow/internal/api/middleware/auth.go (0.0%)</option>
				
				<option value="file8">fiscaflow/internal/api/routes/routes.go (0.0%)</option>
				
				<option value="file9">fiscaflow/internal/api/server/server.go (0.0%)</option>
				
				<option value="file10">fiscaflow/internal/config/config.go (0.0%)</option>
				
				<option value="file11">fiscaflow/internal/domain/analytics/mocks/mock_repository.go (0.0%)</option>
				
				<option value="file12">fiscaflow/internal/domain/analytics/mocks/mock_service.go (0.0%)</option>
				
				<option value="file13">fiscaflow/internal/domain/analytics/model.go (0.0%)</option>
				
				<option value="file14">fiscaflow/internal/domain/analytics/repository.go (0.0%)</option>
				
				<option value="file15">fiscaflow/internal/domain/analytics/service.go (12.3%)</option>
				
				<option value="file16">fiscaflow/internal/domain/budget/mocks/mock_service.go (0.0%)</option>
				
				<option value="file17">fiscaflow/internal/domain/budget/model.go (0.0%)</option>
				
				<option value="file18">fiscaflow/internal/domain/budget/repository.go (0.0%)</option>
				
				<option value="file19">fiscaflow/internal/domain/budget/service.go (37.5%)</option>
				
				<option value="file20">fiscaflow/internal/domain/transaction/model.go (0.0%)</option>
				
				<option value="file21">fiscaflow/internal/domain/transaction/repository.go (0.0%)</option>
				
				<option value="file22">fiscaflow/internal/domain/transaction/service.go (23.6%)</option>
				
				<option value="file23">fiscaflow/internal/domain/user/model.go (0.0%)</option>
				
				<option value="file24">fiscaflow/internal/domain/user/repository.go (0.0%)</option>
				
				<option value="file25">fiscaflow/internal/domain/user/service.go (47.2%)</option>
				
				<option value="file26">fiscaflow/internal/infrastructure/database/postgres.go (0.0%)</option>
				
				<option value="file27">fiscaflow/internal/observability/logging/logger.go (0.0%)</option>
				
				<option value="file28">fiscaflow/internal/observability/tracing/tracer.go (0.0%)</option>
				
				<option value="file29">fiscaflow/tests/integration/test_helpers.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/otel"
        "go.uber.org/zap"

        "fiscaflow/internal/api/server"
        "fiscaflow/internal/config"
        "fiscaflow/internal/observability/logging"
        "fiscaflow/internal/observability/tracing"

        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func main() <span class="cov0" title="0">{
        // Initialize logger
        logger := logging.NewLogger()
        defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        // Log the error but don't fail the application
                        fmt.Fprintf(os.Stderr, "Failed to sync logger: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">logger.Info("Starting FiscaFlow application...")

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to load configuration", zap.Error(err))
        }</span>

        // Initialize OpenTelemetry tracer
        <span class="cov0" title="0">tracer, err := tracing.InitTracer(cfg.OpenTelemetry.Endpoint)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize tracer", zap.Error(err))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := tracing.ShutdownTracer(tracer, context.Background()); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to shutdown tracer", zap.Error(err))
                }</span>
        }()

        // Set global tracer
        <span class="cov0" title="0">otel.SetTracerProvider(tracer)

        // Create Gin router
        router := gin.New()

        // Add middleware
        router.Use(gin.Recovery())
        router.Use(logging.GinLogger(logger))

        // Initialize and setup API server
        apiServer := server.New(cfg, logger)
        apiServer.SetupRoutes(router)

        // Health check endpoint
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().UTC(),
                        "service":   "fiscaflow",
                        "version":   "1.0.0",
                })
        }</span>)

        // Ready check endpoint
        <span class="cov0" title="0">router.GET("/ready", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":    "ready",
                        "timestamp": time.Now().UTC(),
                })
        }</span>)

        // Serve Swagger UI and OpenAPI spec
        <span class="cov0" title="0">router.GET("/swagger/doc.json", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("docs/swagger.yaml")
        }</span>)
        <span class="cov0" title="0">router.GET("/swagger/", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/swagger/doc.json")))
        router.GET("/swagger/index.html", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/swagger/doc.json")))

        // Start server
        srv := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
                Handler: router,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting HTTP server", zap.String("address", srv.Addr))
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start server", zap.Error(err))
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        // Create a deadline for server shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Attempt graceful shutdown
        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"

        "fiscaflow/internal/domain/transaction"
)

// AccountHandler handles account-related HTTP requests
type AccountHandler struct {
        Service transaction.Service
}

// NewAccountHandler creates a new AccountHandler
func NewAccountHandler(service transaction.Service) *AccountHandler <span class="cov10" title="6">{
        return &amp;AccountHandler{Service: service}
}</span>

// RegisterRoutes registers account routes
func (h *AccountHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov0" title="0">{
        acc := rg.Group("/accounts")
        acc.POST("", h.CreateAccount)
        acc.GET("", h.ListAccounts)
        acc.GET(":id", h.GetAccount)
        acc.PUT(":id", h.UpdateAccount)
        acc.DELETE(":id", h.DeleteAccount)
}</span>

// CreateAccount handles POST /accounts
func (h *AccountHandler) CreateAccount(c *gin.Context) <span class="cov4" title="2">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "CreateAccount")
        defer span.End()

        // Get user ID from context (set by auth middleware)
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov1" title="1">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov1" title="1">var req transaction.CreateAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">account, err := h.Service.CreateAccount(ctx, userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusCreated, account)</span>
}

// GetAccount handles GET /accounts/:id
func (h *AccountHandler) GetAccount(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "GetAccount")
        defer span.End()

        // Get user ID from context (set by auth middleware)
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov1" title="1">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov1" title="1">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid account id"})
                return
        }</span>

        <span class="cov1" title="1">account, err := h.Service.GetAccount(ctx, userID, id)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, transaction.ErrAccountNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "account not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, account)</span>
}

// ListAccounts handles GET /accounts
func (h *AccountHandler) ListAccounts(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "ListAccounts")
        defer span.End()

        // Get user ID from context (set by auth middleware)
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov1" title="1">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov1" title="1">accounts, err := h.Service.GetAccounts(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, accounts)</span>
}

// UpdateAccount handles PUT /accounts/:id
func (h *AccountHandler) UpdateAccount(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "UpdateAccount")
        defer span.End()

        // Get user ID from context (set by auth middleware)
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov1" title="1">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov1" title="1">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid account id"})
                return
        }</span>

        <span class="cov1" title="1">var req transaction.CreateAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">account, err := h.Service.UpdateAccount(ctx, userID, id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrAccountNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "account not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov1" title="1">c.JSON(http.StatusOK, account)</span>
}

// DeleteAccount handles DELETE /accounts/:id
func (h *AccountHandler) DeleteAccount(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "DeleteAccount")
        defer span.End()

        // Get user ID from context (set by auth middleware)
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov1" title="1">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov1" title="1">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid account id"})
                return
        }</span>

        <span class="cov1" title="1">if err := h.Service.DeleteAccount(ctx, userID, id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrAccountNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "account not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "fiscaflow/internal/domain/analytics"
)

// AnalyticsHandler handles analytics-related HTTP requests
type AnalyticsHandler struct {
        analyticsService analytics.Service
}

// NewAnalyticsHandler creates a new analytics handler
func NewAnalyticsHandler(analyticsService analytics.Service) *AnalyticsHandler <span class="cov10" title="20">{
        return &amp;AnalyticsHandler{
                analyticsService: analyticsService,
        }
}</span>

// CategorizeTransaction handles POST /api/v1/analytics/categorize
func (h *AnalyticsHandler) CategorizeTransaction(c *gin.Context) <span class="cov4" title="3">{
        var req analytics.CategorizationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov3" title="2">response, err := h.analyticsService.CategorizeTransaction(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"categorization": response})</span>
}

// CreateCategorizationRule handles POST /api/v1/analytics/categorization-rules
func (h *AnalyticsHandler) CreateCategorizationRule(c *gin.Context) <span class="cov4" title="3">{
        var req analytics.CreateCategorizationRuleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov3" title="2">response, err := h.analyticsService.CreateCategorizationRule(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, gin.H{"categorization_rule": response})</span>
}

// GetCategorizationRule handles GET /api/v1/analytics/categorization-rules/:id
func (h *AnalyticsHandler) GetCategorizationRule(c *gin.Context) <span class="cov4" title="3">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid rule ID"})
                return
        }</span>

        <span class="cov3" title="2">response, err := h.analyticsService.GetCategorizationRule(c.Request.Context(), id)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"categorization_rule": response})</span>
}

// ListCategorizationRules handles GET /api/v1/analytics/categorization-rules
func (h *AnalyticsHandler) ListCategorizationRules(c *gin.Context) <span class="cov1" title="1">{
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))

        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov1" title="1">rules, err := h.analyticsService.ListCategorizationRules(c.Request.Context(), offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"categorization_rules": rules})</span>
}

// UpdateCategorizationRule handles PUT /api/v1/analytics/categorization-rules/:id
func (h *AnalyticsHandler) UpdateCategorizationRule(c *gin.Context) <span class="cov5" title="4">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid rule ID"})
                return
        }</span>

        <span class="cov4" title="3">var req analytics.UpdateCategorizationRuleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov3" title="2">response, err := h.analyticsService.UpdateCategorizationRule(c.Request.Context(), id, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"categorization_rule": response})</span>
}

// DeleteCategorizationRule handles DELETE /api/v1/analytics/categorization-rules/:id
func (h *AnalyticsHandler) DeleteCategorizationRule(c *gin.Context) <span class="cov4" title="3">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid rule ID"})
                return
        }</span>

        <span class="cov3" title="2">if err := h.analyticsService.DeleteCategorizationRule(c.Request.Context(), id); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}

// AnalyzeSpending handles POST /api/v1/analytics/spending
func (h *AnalyticsHandler) AnalyzeSpending(c *gin.Context) <span class="cov4" title="3">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">var req analytics.SpendingAnalysisRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov1" title="1">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov1" title="1">response, err := h.analyticsService.AnalyzeSpending(c.Request.Context(), userUUID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"analysis": response})</span>
}

// GetSpendingInsights handles GET /api/v1/analytics/spending/insights
func (h *AnalyticsHandler) GetSpendingInsights(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">startDateStr := c.Query("start_date")
        endDateStr := c.Query("end_date")

        if startDateStr == "" || endDateStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "start_date and end_date are required"})
                return
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid start_date format (YYYY-MM-DD)"})
                return
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid end_date format (YYYY-MM-DD)"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">insights, err := h.analyticsService.GetSpendingInsights(c.Request.Context(), userUUID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"insights": insights})</span>
}

// RegisterRoutes registers all analytics routes
func (h *AnalyticsHandler) RegisterRoutes(api *gin.RouterGroup) <span class="cov0" title="0">{
        analytics := api.Group("/analytics")
        </span><span class="cov0" title="0">{
                // Categorization
                analytics.POST("/categorize", h.CategorizeTransaction)

                // Categorization rules
                analytics.POST("/categorization-rules", h.CreateCategorizationRule)
                analytics.GET("/categorization-rules", h.ListCategorizationRules)
                analytics.GET("/categorization-rules/:id", h.GetCategorizationRule)
                analytics.PUT("/categorization-rules/:id", h.UpdateCategorizationRule)
                analytics.DELETE("/categorization-rules/:id", h.DeleteCategorizationRule)

                // Spending analysis
                analytics.POST("/spending", h.AnalyzeSpending)
                analytics.GET("/spending/insights", h.GetSpendingInsights)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "fiscaflow/internal/domain/budget"
)

// BudgetHandler handles budget-related HTTP requests
type BudgetHandler struct {
        budgetService budget.Service
}

// NewBudgetHandler creates a new budget handler
func NewBudgetHandler(budgetService budget.Service) *BudgetHandler <span class="cov10" title="15">{
        return &amp;BudgetHandler{
                budgetService: budgetService,
        }
}</span>

// CreateBudget handles POST /api/v1/budgets
func (h *BudgetHandler) CreateBudget(c *gin.Context) <span class="cov4" title="3">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov4" title="3">var req budget.CreateBudgetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov3" title="2">budgetResponse, err := h.budgetService.CreateBudget(c.Request.Context(), userUUID, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, gin.H{"budget": budgetResponse})</span>
}

// GetBudget handles GET /api/v1/budgets/:id
func (h *BudgetHandler) GetBudget(c *gin.Context) <span class="cov4" title="3">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov4" title="3">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov3" title="2">budgetResponse, err := h.budgetService.GetBudget(c.Request.Context(), userUUID, budgetID)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"budget": budgetResponse})</span>
}

// ListBudgets handles GET /api/v1/budgets
func (h *BudgetHandler) ListBudgets(c *gin.Context) <span class="cov3" title="2">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))

        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov3" title="2">budgets, err := h.budgetService.ListBudgets(c.Request.Context(), userUUID, offset, limit)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"budgets": budgets})</span>
}

// UpdateBudget handles PUT /api/v1/budgets/:id
func (h *BudgetHandler) UpdateBudget(c *gin.Context) <span class="cov5" title="4">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov5" title="4">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov4" title="3">var req budget.UpdateBudgetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov3" title="2">budgetResponse, err := h.budgetService.UpdateBudget(c.Request.Context(), userUUID, budgetID, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"budget": budgetResponse})</span>
}

// DeleteBudget handles DELETE /api/v1/budgets/:id
func (h *BudgetHandler) DeleteBudget(c *gin.Context) <span class="cov4" title="3">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov4" title="3">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov3" title="2">if err := h.budgetService.DeleteBudget(c.Request.Context(), userUUID, budgetID); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}

// GetBudgetSummary handles GET /api/v1/budgets/:id/summary
func (h *BudgetHandler) GetBudgetSummary(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">summary, err := h.budgetService.GetBudgetSummary(c.Request.Context(), userUUID, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"summary": summary})</span>
}

// AddBudgetCategory handles POST /api/v1/budgets/:id/categories
func (h *BudgetHandler) AddBudgetCategory(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov0" title="0">var req budget.CreateBudgetCategoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">categoryResponse, err := h.budgetService.AddBudgetCategory(c.Request.Context(), userUUID, budgetID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"budget_category": categoryResponse})</span>
}

// GetBudgetCategory handles GET /api/v1/budgets/:id/categories/:categoryId
func (h *BudgetHandler) GetBudgetCategory(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov0" title="0">categoryID, err := uuid.Parse(c.Param("categoryId"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid category ID"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">categoryResponse, err := h.budgetService.GetBudgetCategory(c.Request.Context(), userUUID, budgetID, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"budget_category": categoryResponse})</span>
}

// ListBudgetCategories handles GET /api/v1/budgets/:id/categories
func (h *BudgetHandler) ListBudgetCategories(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">categories, err := h.budgetService.ListBudgetCategories(c.Request.Context(), userUUID, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"budget_categories": categories})</span>
}

// UpdateBudgetCategory handles PUT /api/v1/budgets/:id/categories/:categoryId
func (h *BudgetHandler) UpdateBudgetCategory(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov0" title="0">categoryID, err := uuid.Parse(c.Param("categoryId"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid category ID"})
                return
        }</span>

        <span class="cov0" title="0">var req budget.UpdateBudgetCategoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">categoryResponse, err := h.budgetService.UpdateBudgetCategory(c.Request.Context(), userUUID, budgetID, categoryID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"budget_category": categoryResponse})</span>
}

// DeleteBudgetCategory handles DELETE /api/v1/budgets/:id/categories/:categoryId
func (h *BudgetHandler) DeleteBudgetCategory(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid budget ID"})
                return
        }</span>

        <span class="cov0" title="0">categoryID, err := uuid.Parse(c.Param("categoryId"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid category ID"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.budgetService.DeleteBudgetCategory(c.Request.Context(), userUUID, budgetID, categoryID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// RegisterRoutes registers all budget routes
func (h *BudgetHandler) RegisterRoutes(api *gin.RouterGroup) <span class="cov0" title="0">{
        budgets := api.Group("/budgets")
        </span><span class="cov0" title="0">{
                budgets.POST("", h.CreateBudget)
                budgets.GET("", h.ListBudgets)
                budgets.GET("/:id", h.GetBudget)
                budgets.PUT("/:id", h.UpdateBudget)
                budgets.DELETE("/:id", h.DeleteBudget)
                budgets.GET("/:id/summary", h.GetBudgetSummary)

                // Budget categories
                budgets.POST("/:id/categories", h.AddBudgetCategory)
                budgets.GET("/:id/categories", h.ListBudgetCategories)
                budgets.GET("/:id/categories/:categoryId", h.GetBudgetCategory)
                budgets.PUT("/:id/categories/:categoryId", h.UpdateBudgetCategory)
                budgets.DELETE("/:id/categories/:categoryId", h.DeleteBudgetCategory)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"

        "fiscaflow/internal/domain/transaction"
)

// CategoryHandler handles category-related HTTP requests
type CategoryHandler struct {
        Service transaction.Service
}

// NewCategoryHandler creates a new CategoryHandler
func NewCategoryHandler(service transaction.Service) *CategoryHandler <span class="cov10" title="7">{
        return &amp;CategoryHandler{Service: service}
}</span>

// RegisterRoutes registers category routes
func (h *CategoryHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov0" title="0">{
        cat := rg.Group("/categories")
        cat.POST("", h.CreateCategory)
        cat.GET("", h.ListCategories)
        cat.GET(":id", h.GetCategory)
        cat.PUT(":id", h.UpdateCategory)
        cat.DELETE(":id", h.DeleteCategory)
        cat.GET("/default", h.GetDefaultCategories)
}</span>

// CreateCategory handles POST /categories
func (h *CategoryHandler) CreateCategory(c *gin.Context) <span class="cov4" title="2">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "CreateCategory")
        defer span.End()

        var req transaction.CreateCategoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">category, err := h.Service.CreateCategory(ctx, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusCreated, category)</span>
}

// GetCategory handles GET /categories/:id
func (h *CategoryHandler) GetCategory(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "GetCategory")
        defer span.End()

        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid category id"})
                return
        }</span>

        <span class="cov1" title="1">category, err := h.Service.GetCategory(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, transaction.ErrCategoryNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "category not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, category)</span>
}

// ListCategories handles GET /categories
func (h *CategoryHandler) ListCategories(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "ListCategories")
        defer span.End()

        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        categories, err := h.Service.GetCategories(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, categories)</span>
}

// GetDefaultCategories handles GET /categories/default
func (h *CategoryHandler) GetDefaultCategories(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "GetDefaultCategories")
        defer span.End()

        categories, err := h.Service.GetDefaultCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, categories)</span>
}

// UpdateCategory handles PUT /categories/:id
func (h *CategoryHandler) UpdateCategory(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "UpdateCategory")
        defer span.End()

        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid category id"})
                return
        }</span>

        <span class="cov1" title="1">var req transaction.CreateCategoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">category, err := h.Service.UpdateCategory(ctx, id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrCategoryNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "category not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov1" title="1">c.JSON(http.StatusOK, category)</span>
}

// DeleteCategory handles DELETE /categories/:id
func (h *CategoryHandler) DeleteCategory(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "DeleteCategory")
        defer span.End()

        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid category id"})
                return
        }</span>

        <span class="cov1" title="1">if err := h.Service.DeleteCategory(ctx, id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrCategoryNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "category not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"

        "fiscaflow/internal/domain/transaction"
)

// TransactionHandler handles transaction-related HTTP requests
type TransactionHandler struct {
        Service transaction.Service
}

// NewTransactionHandler creates a new TransactionHandler
func NewTransactionHandler(service transaction.Service) *TransactionHandler <span class="cov8" title="1">{
        return &amp;TransactionHandler{Service: service}
}</span>

// RegisterRoutes registers transaction routes
func (h *TransactionHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov8" title="1">{
        tr := rg.Group("/transactions")
        tr.POST("", h.CreateTransaction)
        tr.GET("", h.ListTransactions)
        tr.GET(":id", h.GetTransaction)
        tr.PUT(":id", h.UpdateTransaction)
        tr.DELETE(":id", h.DeleteTransaction)
}</span>

// CreateTransaction handles POST /transactions
func (h *TransactionHandler) CreateTransaction(c *gin.Context) <span class="cov8" title="1">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "CreateTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov8" title="1">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov8" title="1">var req transaction.CreateTransactionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">resp, err := h.Service.CreateTransaction(ctx, uid, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusCreated, resp)</span>
}

// GetTransaction handles GET /transactions/:id
func (h *TransactionHandler) GetTransaction(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "GetTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid transaction id"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Service.GetTransaction(ctx, uid, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrTransactionNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "transaction not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// ListTransactions handles GET /transactions
func (h *TransactionHandler) ListTransactions(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "ListTransactions")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>
        <span class="cov0" title="0">offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        resp, err := h.Service.GetTransactions(ctx, uid, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// UpdateTransaction handles PUT /transactions/:id
func (h *TransactionHandler) UpdateTransaction(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "UpdateTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid transaction id"})
                return
        }</span>

        <span class="cov0" title="0">var req transaction.UpdateTransactionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Service.UpdateTransaction(ctx, uid, id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrTransactionNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "transaction not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// DeleteTransaction handles DELETE /transactions/:id
func (h *TransactionHandler) DeleteTransaction(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("api").Start(c.Request.Context(), "DeleteTransaction")
        defer span.End()

        userID, ok := c.Get("user_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid transaction id"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.Service.DeleteTransaction(ctx, uid, id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, transaction.ErrTransactionNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "transaction not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "context"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.uber.org/zap"

        "fiscaflow/internal/domain/user"
)

// UserHandler handles user-related HTTP requests
type UserHandler struct {
        userService user.Service
        logger      *zap.Logger
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService user.Service, logger *zap.Logger) *UserHandler <span class="cov10" title="10">{
        return &amp;UserHandler{
                userService: userService,
                logger:      logger,
        }
}</span>

// Register handles user registration
func (h *UserHandler) Register(c *gin.Context) <span class="cov5" title="3">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.Register")
        defer span.End()

        var req user.CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(
                attribute.String("user.email", req.Email),
                attribute.String("user.first_name", req.FirstName),
                attribute.String("user.last_name", req.LastName),
        )

        userResponse, err := h.userService.Register(ctx, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrUserAlreadyExists:<span class="cov1" title="1">
                        c.JSON(http.StatusConflict, gin.H{"error": "User already exists"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to register user", zap.Error(err), zap.String("email", req.Email))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register user"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetAttributes(attribute.String("user.id", userResponse.ID.String()))
        span.SetStatus(codes.Ok, "user registered successfully")

        c.JSON(http.StatusCreated, gin.H{
                "message": "User registered successfully",
                "user":    userResponse,
        })</span>
}

// Login handles user login
func (h *UserHandler) Login(c *gin.Context) <span class="cov3" title="2">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.Login")
        defer span.End()

        var req user.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(attribute.String("user.email", req.Email))

        loginResponse, err := h.userService.Login(ctx, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrInvalidCredentials:<span class="cov1" title="1">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})</span>
                case user.ErrUserInactive:<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": "User account is inactive"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to login user", zap.Error(err), zap.String("email", req.Email))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to login"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetAttributes(
                attribute.String("user.id", loginResponse.User.ID.String()),
                attribute.String("user.role", string(loginResponse.User.Role)),
        )
        span.SetStatus(codes.Ok, "user logged in successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Login successful",
                "data":    loginResponse,
        })</span>
}

// GetProfile retrieves user profile
func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov5" title="3">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.GetProfile")
        defer span.End()

        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov1" title="1">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "user_id not found in context")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "invalid user_id type")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(attribute.String("user.id", userUUID.String()))

        userResponse, err := h.userService.GetProfile(ctx, userUUID)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrUserNotFound:<span class="cov1" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to get user profile", zap.Error(err), zap.String("user_id", userUUID.String()))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get profile"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "profile retrieved successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Profile retrieved successfully",
                "user":    userResponse,
        })</span>
}

// UpdateProfile updates user profile
func (h *UserHandler) UpdateProfile(c *gin.Context) <span class="cov3" title="2">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.UpdateProfile")
        defer span.End()

        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "user_id not found in context")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "invalid user_id type")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov3" title="2">var req user.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov3" title="2">span.SetAttributes(attribute.String("user.id", userUUID.String()))

        userResponse, err := h.userService.UpdateProfile(ctx, userUUID, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrUserNotFound:<span class="cov1" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to update user profile", zap.Error(err), zap.String("user_id", userUUID.String()))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})</span>
                }
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "profile updated successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Profile updated successfully",
                "user":    userResponse,
        })</span>
}

// RefreshToken refreshes access token
func (h *UserHandler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.RefreshToken")
        defer span.End()

        var req struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid request body")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String("refresh_token", req.RefreshToken))

        loginResponse, err := h.userService.RefreshToken(ctx, req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())

                switch err </span>{
                case user.ErrInvalidRefreshToken:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid refresh token"})</span>
                case user.ErrRefreshTokenExpired:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Refresh token expired"})</span>
                default:<span class="cov0" title="0">
                        h.logger.Error("Failed to refresh token", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to refresh token"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">span.SetAttributes(attribute.String("user.id", loginResponse.User.ID.String()))
        span.SetStatus(codes.Ok, "token refreshed successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Token refreshed successfully",
                "data":    loginResponse,
        })</span>
}

// Logout handles user logout
func (h *UserHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.Logout")
        defer span.End()

        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "user_id not found in context")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">userUUID, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "invalid user_id type")
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        // Get session ID from header or query param
        <span class="cov0" title="0">sessionIDStr := c.GetHeader("X-Session-ID")
        if sessionIDStr == "" </span><span class="cov0" title="0">{
                sessionIDStr = c.Query("session_id")
        }</span>

        <span class="cov0" title="0">if sessionIDStr == "" </span><span class="cov0" title="0">{
                span.RecordError(user.ErrInvalidToken)
                span.SetStatus(codes.Error, "session_id not provided")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Session ID is required"})
                return
        }</span>

        <span class="cov0" title="0">sessionID, err := uuid.Parse(sessionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "invalid session_id format")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid session ID format"})
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("user.id", userUUID.String()),
                attribute.String("session.id", sessionID.String()),
        )

        if err := h.userService.Logout(ctx, userUUID, sessionID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                h.logger.Error("Failed to logout user", zap.Error(err), zap.String("user_id", userUUID.String()))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to logout"})
                return
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "user logged out successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Logged out successfully",
        })</span>
}

// ListUsers handles listing users (admin only)
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("user").Start(c.Request.Context(), "user.ListUsers")
        defer span.End()

        // Get pagination parameters
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.Int("offset", offset),
                attribute.Int("limit", limit),
        )

        users, err := h.userService.(interface {
                List(ctx context.Context, offset, limit int) ([]user.User, error)
        }).List(ctx, offset, limit)

        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                h.logger.Error("Failed to list users", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list users"})
                return
        }</span>

        // Convert to responses
        <span class="cov0" title="0">userResponses := make([]*user.UserResponse, len(users))
        for i, u := range users </span><span class="cov0" title="0">{
                userResponses[i] = &amp;user.UserResponse{
                        ID:            u.ID,
                        Email:         u.Email,
                        FirstName:     u.FirstName,
                        LastName:      u.LastName,
                        Phone:         u.Phone,
                        DateOfBirth:   u.DateOfBirth,
                        Timezone:      u.Timezone,
                        Locale:        u.Locale,
                        Role:          u.Role,
                        Status:        u.Status,
                        EmailVerified: u.EmailVerified,
                        PhoneVerified: u.PhoneVerified,
                        LastLoginAt:   u.LastLoginAt,
                        CreatedAt:     u.CreatedAt,
                        UpdatedAt:     u.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "users listed successfully")

        c.JSON(http.StatusOK, gin.H{
                "message": "Users retrieved successfully",
                "users":   userResponses,
                "pagination": gin.H{
                        "offset": offset,
                        "limit":  limit,
                        "count":  len(userResponses),
                },
        })</span>
}

// RegisterRoutes registers user-related routes
func (h *UserHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov0" title="0">{
        rg.POST("/users/register", h.Register)
        rg.POST("/users/login", h.Login)
        rg.GET("/users/profile", h.GetProfile)
        rg.PUT("/users/profile", h.UpdateProfile)
        rg.POST("/users/refresh-token", h.RefreshToken)
        rg.POST("/users/logout", h.Logout)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "fiscaflow/internal/domain/user"
)

// AuthMiddleware creates authentication middleware
func AuthMiddleware(userService user.Service) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Authorization header is required",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if it's a Bearer token
                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Invalid authorization header format",
                        })
                        c.Abort()
                        return
                }</span>

                // Extract token
                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")

                // Validate token
                claims, err := userService.ValidateToken(c.Request.Context(), token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Invalid or expired token",
                        })
                        c.Abort()
                        return
                }</span>

                // Set user ID in context
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Set("user_role", claims.Role)

                c.Next()</span>
        }
}

// GetUserIDFromContext extracts user ID from gin context
func GetUserIDFromContext(c *gin.Context) (uuid.UUID, bool) <span class="cov0" title="0">{
        userIDInterface, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return uuid.Nil, false
        }</span>

        <span class="cov0" title="0">userID, ok := userIDInterface.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                return uuid.Nil, false
        }</span>

        <span class="cov0" title="0">return userID, true</span>
}

// GetUserEmailFromContext extracts user email from gin context
func GetUserEmailFromContext(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        emailInterface, exists := c.Get("user_email")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">email, ok := emailInterface.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">return email, true</span>
}

// GetUserRoleFromContext extracts user role from gin context
func GetUserRoleFromContext(c *gin.Context) (user.UserRole, bool) <span class="cov0" title="0">{
        roleInterface, exists := c.Get("user_role")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">role, ok := roleInterface.(user.UserRole)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">return role, true</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package routes

import (
        "fiscaflow/internal/api/handlers"
        "fiscaflow/internal/api/middleware"
        "fiscaflow/internal/domain/user"

        "github.com/gin-gonic/gin"
)

// RegisterAPIRoutes registers all API routes
func RegisterAPIRoutes(r *gin.Engine, userHandler *handlers.UserHandler, transactionHandler *handlers.TransactionHandler, budgetHandler *handlers.BudgetHandler, analyticsHandler *handlers.AnalyticsHandler, userService user.Service) <span class="cov0" title="0">{
        api := r.Group("/api/v1")

        // User routes (public)
        userHandler.RegisterRoutes(api)

        // Protected routes
        api.Use(middleware.AuthMiddleware(userService))

        // Transaction routes
        transactionHandler.RegisterRoutes(api)

        // Budget routes
        budgetHandler.RegisterRoutes(api)

        // Analytics routes
        analyticsHandler.RegisterRoutes(api)
}</span>

// AuthMiddleware is a placeholder for the actual authentication middleware
func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // This should set user_id in context after validating JWT
                // For now, assume user_id is set for testing
                // c.Set("user_id", uuid.MustParse("00000000-0000-0000-0000-000000000001"))
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"

        "fiscaflow/internal/api/handlers"
        "fiscaflow/internal/api/middleware"
        "fiscaflow/internal/config"
        "fiscaflow/internal/domain/analytics"
        "fiscaflow/internal/domain/budget"
        "fiscaflow/internal/domain/transaction"
        "fiscaflow/internal/domain/user"
        "fiscaflow/internal/infrastructure/database"
)

// Server represents the API server
type Server struct {
        config             *config.Config
        logger             *zap.Logger
        userService        user.Service
        userHandler        *handlers.UserHandler
        transactionService transaction.Service
        transactionHandler *handlers.TransactionHandler
        categoryHandler    *handlers.CategoryHandler
        accountHandler     *handlers.AccountHandler
        budgetService      budget.Service
        budgetHandler      *handlers.BudgetHandler
        analyticsService   analytics.Service
        analyticsHandler   *handlers.AnalyticsHandler
}

// New creates a new API server instance
func New(cfg *config.Config, logger *zap.Logger) *Server <span class="cov0" title="0">{
        // Initialize database
        dbConfig := &amp;database.Config{
                Host:            cfg.Database.Host,
                Port:            cfg.Database.Port,
                User:            cfg.Database.User,
                Password:        cfg.Database.Password,
                DBName:          cfg.Database.DBName,
                SSLMode:         cfg.Database.SSLMode,
                MaxOpenConns:    cfg.Database.MaxOpenConns,
                MaxIdleConns:    cfg.Database.MaxIdleConns,
                ConnMaxLifetime: cfg.Database.ConnMaxLifetime,
        }

        db, err := database.NewDatabase(dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to connect to database", zap.Error(err))
        }</span>

        // Auto-migrate database
        <span class="cov0" title="0">if err := db.AutoMigrate(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to run database migrations", zap.Error(err))
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">userRepo := user.NewRepository(db.GetDB())
        transactionRepo := transaction.NewRepository(db.GetDB())
        budgetRepo := budget.NewRepository(db.GetDB())
        analyticsRepo := analytics.NewRepository(db.GetDB())

        // Initialize services
        userService := user.NewService(userRepo, cfg.JWT.Secret)
        transactionService := transaction.NewService(transactionRepo)
        budgetService := budget.NewService(budgetRepo)
        analyticsService := analytics.NewService(analyticsRepo)

        // Initialize handlers
        userHandler := handlers.NewUserHandler(userService, logger)
        transactionHandler := handlers.NewTransactionHandler(transactionService)
        categoryHandler := handlers.NewCategoryHandler(transactionService)
        accountHandler := handlers.NewAccountHandler(transactionService)
        budgetHandler := handlers.NewBudgetHandler(budgetService)
        analyticsHandler := handlers.NewAnalyticsHandler(analyticsService)

        return &amp;Server{
                config:             cfg,
                logger:             logger,
                userService:        userService,
                userHandler:        userHandler,
                transactionService: transactionService,
                transactionHandler: transactionHandler,
                categoryHandler:    categoryHandler,
                accountHandler:     accountHandler,
                budgetService:      budgetService,
                budgetHandler:      budgetHandler,
                analyticsService:   analyticsService,
                analyticsHandler:   analyticsHandler,
        }</span>
}

// SetupRoutes configures all API routes
func (s *Server) SetupRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // API v1 group
        v1 := router.Group("/api/v1")

        // User routes
        users := v1.Group("/users")
        </span><span class="cov0" title="0">{
                users.POST("/register", s.userHandler.Register)
                users.POST("/login", s.userHandler.Login)
                users.POST("/logout", s.userHandler.Logout)
                users.POST("/refresh", s.userHandler.RefreshToken)

                // Protected routes
                protected := users.Group("")
                protected.Use(middleware.AuthMiddleware(s.userService))
                </span><span class="cov0" title="0">{
                        protected.GET("/profile", s.userHandler.GetProfile)
                        protected.PUT("/profile", s.userHandler.UpdateProfile)
                }</span>
        }

        // Transaction routes (protected)
        <span class="cov0" title="0">transactions := v1.Group("/transactions")
        transactions.Use(middleware.AuthMiddleware(s.userService))
        </span><span class="cov0" title="0">{
                transactions.POST("", s.transactionHandler.CreateTransaction)
                transactions.GET("", s.transactionHandler.ListTransactions)
                transactions.GET(":id", s.transactionHandler.GetTransaction)
                transactions.PUT(":id", s.transactionHandler.UpdateTransaction)
                transactions.DELETE(":id", s.transactionHandler.DeleteTransaction)
        }</span>

        // Category routes
        <span class="cov0" title="0">categories := v1.Group("/categories")
        </span><span class="cov0" title="0">{
                // Public routes
                categories.GET("/default", s.categoryHandler.GetDefaultCategories)

                // Protected routes
                protectedCategories := categories.Group("")
                protectedCategories.Use(middleware.AuthMiddleware(s.userService))
                </span><span class="cov0" title="0">{
                        protectedCategories.POST("", s.categoryHandler.CreateCategory)
                        protectedCategories.GET("", s.categoryHandler.ListCategories)
                        protectedCategories.GET(":id", s.categoryHandler.GetCategory)
                        protectedCategories.PUT(":id", s.categoryHandler.UpdateCategory)
                        protectedCategories.DELETE(":id", s.categoryHandler.DeleteCategory)
                }</span>
        }

        // Account routes (protected)
        <span class="cov0" title="0">accounts := v1.Group("/accounts")
        accounts.Use(middleware.AuthMiddleware(s.userService))
        </span><span class="cov0" title="0">{
                accounts.POST("", s.accountHandler.CreateAccount)
                accounts.GET("", s.accountHandler.ListAccounts)
                accounts.GET(":id", s.accountHandler.GetAccount)
                accounts.PUT(":id", s.accountHandler.UpdateAccount)
                accounts.DELETE(":id", s.accountHandler.DeleteAccount)
        }</span>

        // Budget routes (protected)
        <span class="cov0" title="0">budgets := v1.Group("/budgets")
        budgets.Use(middleware.AuthMiddleware(s.userService))
        </span><span class="cov0" title="0">{
                budgets.POST("", s.budgetHandler.CreateBudget)
                budgets.GET("", s.budgetHandler.ListBudgets)
                budgets.GET(":id", s.budgetHandler.GetBudget)
                budgets.PUT(":id", s.budgetHandler.UpdateBudget)
                budgets.DELETE(":id", s.budgetHandler.DeleteBudget)
                budgets.GET(":id/summary", s.budgetHandler.GetBudgetSummary)

                // Budget categories
                budgets.POST(":id/categories", s.budgetHandler.AddBudgetCategory)
                budgets.GET(":id/categories", s.budgetHandler.ListBudgetCategories)
                budgets.GET(":id/categories/:categoryId", s.budgetHandler.GetBudgetCategory)
                budgets.PUT(":id/categories/:categoryId", s.budgetHandler.UpdateBudgetCategory)
                budgets.DELETE(":id/categories/:categoryId", s.budgetHandler.DeleteBudgetCategory)
        }</span>

        // Analytics routes (protected)
        <span class="cov0" title="0">analytics := v1.Group("/analytics")
        analytics.Use(middleware.AuthMiddleware(s.userService))
        </span><span class="cov0" title="0">{
                // Categorization
                analytics.POST("/categorize", s.analyticsHandler.CategorizeTransaction)

                // Categorization rules
                analytics.POST("/categorization-rules", s.analyticsHandler.CreateCategorizationRule)
                analytics.GET("/categorization-rules", s.analyticsHandler.ListCategorizationRules)
                analytics.GET("/categorization-rules/:id", s.analyticsHandler.GetCategorizationRule)
                analytics.PUT("/categorization-rules/:id", s.analyticsHandler.UpdateCategorizationRule)
                analytics.DELETE("/categorization-rules/:id", s.analyticsHandler.DeleteCategorizationRule)

                // Spending analysis
                analytics.POST("/spending", s.analyticsHandler.AnalyzeSpending)
                analytics.GET("/spending/insights", s.analyticsHandler.GetSpendingInsights)
        }</span>

        <span class="cov0" title="0">s.logger.Info("API routes configured")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// Config holds all configuration for the application
type Config struct {
        Server        ServerConfig
        Database      DatabaseConfig
        Redis         RedisConfig
        OpenTelemetry OpenTelemetryConfig
        JWT           JWTConfig
        Elasticsearch ElasticsearchConfig
        MinIO         MinIOConfig
        RabbitMQ      RabbitMQConfig
}

// ServerConfig holds server configuration
type ServerConfig struct {
        Port         int
        Host         string
        ReadTimeout  time.Duration
        WriteTimeout time.Duration
        IdleTimeout  time.Duration
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Host            string
        Port            int
        User            string
        Password        string
        DBName          string
        SSLMode         string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
        Host     string
        Port     int
        Password string
        DB       int
}

// OpenTelemetryConfig holds OpenTelemetry configuration
type OpenTelemetryConfig struct {
        Endpoint       string
        ServiceName    string
        ServiceVersion string
}

// JWTConfig holds JWT configuration
type JWTConfig struct {
        Secret            string
        Expiration        time.Duration
        RefreshExpiration time.Duration
}

// ElasticsearchConfig holds Elasticsearch configuration
type ElasticsearchConfig struct {
        URL      string
        Username string
        Password string
}

// MinIOConfig holds MinIO configuration
type MinIOConfig struct {
        Endpoint        string
        AccessKeyID     string
        SecretAccessKey string
        UseSSL          bool
}

// RabbitMQConfig holds RabbitMQ configuration
type RabbitMQConfig struct {
        URL      string
        Username string
        Password string
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists (optional, error is ignored)
        _ = godotenv.Load()

        config := &amp;Config{
                Server: ServerConfig{
                        Port:         getEnvAsInt("SERVER_PORT", 8080),
                        Host:         getEnv("SERVER_HOST", "0.0.0.0"),
                        ReadTimeout:  getEnvAsDuration("SERVER_READ_TIMEOUT", 15*time.Second),
                        WriteTimeout: getEnvAsDuration("SERVER_WRITE_TIMEOUT", 15*time.Second),
                        IdleTimeout:  getEnvAsDuration("SERVER_IDLE_TIMEOUT", 60*time.Second),
                },
                Database: DatabaseConfig{
                        Host:            getEnv("DATABASE_HOST", "localhost"),
                        Port:            getEnvAsInt("DATABASE_PORT", 5432),
                        User:            getEnv("DATABASE_USER", "postgres"),
                        Password:        getEnv("DATABASE_PASSWORD", "password"),
                        DBName:          getEnv("DATABASE_NAME", "fiscaflow"),
                        SSLMode:         getEnv("DATABASE_SSL_MODE", "disable"),
                        MaxOpenConns:    getEnvAsInt("DATABASE_MAX_OPEN_CONNS", 25),
                        MaxIdleConns:    getEnvAsInt("DATABASE_MAX_IDLE_CONNS", 5),
                        ConnMaxLifetime: getEnvAsDuration("DATABASE_CONN_MAX_LIFETIME", 5*time.Minute),
                },
                Redis: RedisConfig{
                        Host:     getEnv("REDIS_HOST", "localhost"),
                        Port:     getEnvAsInt("REDIS_PORT", 6379),
                        Password: getEnv("REDIS_PASSWORD", ""),
                        DB:       getEnvAsInt("REDIS_DB", 0),
                },
                OpenTelemetry: OpenTelemetryConfig{
                        Endpoint:       getEnv("OTEL_ENDPOINT", "jaeger:4317"),
                        ServiceName:    getEnv("OTEL_SERVICE_NAME", "fiscaflow"),
                        ServiceVersion: getEnv("OTEL_SERVICE_VERSION", "1.0.0"),
                },
                JWT: JWTConfig{
                        Secret:            getEnv("JWT_SECRET", "your-secret-key"),
                        Expiration:        getEnvAsDuration("JWT_EXPIRATION", 15*time.Minute),
                        RefreshExpiration: getEnvAsDuration("JWT_REFRESH_EXPIRATION", 7*24*time.Hour),
                },
                Elasticsearch: ElasticsearchConfig{
                        URL:      getEnv("ELASTICSEARCH_URL", "http://localhost:9200"),
                        Username: getEnv("ELASTICSEARCH_USERNAME", ""),
                        Password: getEnv("ELASTICSEARCH_PASSWORD", ""),
                },
                MinIO: MinIOConfig{
                        Endpoint:        getEnv("MINIO_ENDPOINT", "localhost:9000"),
                        AccessKeyID:     getEnv("MINIO_ACCESS_KEY_ID", "minioadmin"),
                        SecretAccessKey: getEnv("MINIO_SECRET_ACCESS_KEY", "minioadmin"),
                        UseSSL:          getEnvAsBool("MINIO_USE_SSL", false),
                },
                RabbitMQ: RabbitMQConfig{
                        URL:      getEnv("RABBITMQ_URL", "amqp://guest:guest@localhost:5672/"),
                        Username: getEnv("RABBITMQ_USERNAME", "guest"),
                        Password: getEnv("RABBITMQ_PASSWORD", "guest"),
                },
        }

        return config, nil
}</span>

// GetDSN returns the database connection string
func (c *DatabaseConfig) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.DBName, c.SSLMode)
}</span>

// GetRedisAddr returns the Redis address
func (c *RedisConfig) GetAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>

// Helper functions
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/analytics/repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        analytics "fiscaflow/internal/domain/analytics"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov0" title="0">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateCategorizationRule mocks base method.
func (m *MockRepository) CreateCategorizationRule(ctx context.Context, rule *analytics.CategorizationRule) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateCategorizationRule", ctx, rule)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateCategorizationRule indicates an expected call of CreateCategorizationRule.
func (mr *MockRepositoryMockRecorder) CreateCategorizationRule(ctx, rule interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCategorizationRule", reflect.TypeOf((*MockRepository)(nil).CreateCategorizationRule), ctx, rule)
}</span>

// CreateSpendingAnalysis mocks base method.
func (m *MockRepository) CreateSpendingAnalysis(ctx context.Context, analysis *analytics.SpendingAnalysis) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateSpendingAnalysis", ctx, analysis)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateSpendingAnalysis indicates an expected call of CreateSpendingAnalysis.
func (mr *MockRepositoryMockRecorder) CreateSpendingAnalysis(ctx, analysis interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSpendingAnalysis", reflect.TypeOf((*MockRepository)(nil).CreateSpendingAnalysis), ctx, analysis)
}</span>

// DeleteCategorizationRule mocks base method.
func (m *MockRepository) DeleteCategorizationRule(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteCategorizationRule", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteCategorizationRule indicates an expected call of DeleteCategorizationRule.
func (mr *MockRepositoryMockRecorder) DeleteCategorizationRule(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCategorizationRule", reflect.TypeOf((*MockRepository)(nil).DeleteCategorizationRule), ctx, id)
}</span>

// GetActiveCategorizationRules mocks base method.
func (m *MockRepository) GetActiveCategorizationRules(ctx context.Context) ([]analytics.CategorizationRule, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetActiveCategorizationRules", ctx)
        ret0, _ := ret[0].([]analytics.CategorizationRule)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetActiveCategorizationRules indicates an expected call of GetActiveCategorizationRules.
func (mr *MockRepositoryMockRecorder) GetActiveCategorizationRules(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActiveCategorizationRules", reflect.TypeOf((*MockRepository)(nil).GetActiveCategorizationRules), ctx)
}</span>

// GetCategorizationRuleByID mocks base method.
func (m *MockRepository) GetCategorizationRuleByID(ctx context.Context, id uuid.UUID) (*analytics.CategorizationRule, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategorizationRuleByID", ctx, id)
        ret0, _ := ret[0].(*analytics.CategorizationRule)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategorizationRuleByID indicates an expected call of GetCategorizationRuleByID.
func (mr *MockRepositoryMockRecorder) GetCategorizationRuleByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategorizationRuleByID", reflect.TypeOf((*MockRepository)(nil).GetCategorizationRuleByID), ctx, id)
}</span>

// GetCategorizationRules mocks base method.
func (m *MockRepository) GetCategorizationRules(ctx context.Context, offset, limit int) ([]analytics.CategorizationRule, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategorizationRules", ctx, offset, limit)
        ret0, _ := ret[0].([]analytics.CategorizationRule)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategorizationRules indicates an expected call of GetCategorizationRules.
func (mr *MockRepositoryMockRecorder) GetCategorizationRules(ctx, offset, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategorizationRules", reflect.TypeOf((*MockRepository)(nil).GetCategorizationRules), ctx, offset, limit)
}</span>

// GetCategoryByID mocks base method.
func (m *MockRepository) GetCategoryByID(ctx context.Context, id uuid.UUID) (*analytics.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryByID", ctx, id)
        ret0, _ := ret[0].(*analytics.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryByID indicates an expected call of GetCategoryByID.
func (mr *MockRepositoryMockRecorder) GetCategoryByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryByID", reflect.TypeOf((*MockRepository)(nil).GetCategoryByID), ctx, id)
}</span>

// GetSimilarTransactions mocks base method.
func (m *MockRepository) GetSimilarTransactions(ctx context.Context, description string, limit int) ([]analytics.Transaction, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSimilarTransactions", ctx, description, limit)
        ret0, _ := ret[0].([]analytics.Transaction)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSimilarTransactions indicates an expected call of GetSimilarTransactions.
func (mr *MockRepositoryMockRecorder) GetSimilarTransactions(ctx, description, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSimilarTransactions", reflect.TypeOf((*MockRepository)(nil).GetSimilarTransactions), ctx, description, limit)
}</span>

// GetSpendingAnalysisByID mocks base method.
func (m *MockRepository) GetSpendingAnalysisByID(ctx context.Context, id uuid.UUID) (*analytics.SpendingAnalysis, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSpendingAnalysisByID", ctx, id)
        ret0, _ := ret[0].(*analytics.SpendingAnalysis)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSpendingAnalysisByID indicates an expected call of GetSpendingAnalysisByID.
func (mr *MockRepositoryMockRecorder) GetSpendingAnalysisByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSpendingAnalysisByID", reflect.TypeOf((*MockRepository)(nil).GetSpendingAnalysisByID), ctx, id)
}</span>

// GetSpendingAnalysisByUser mocks base method.
func (m *MockRepository) GetSpendingAnalysisByUser(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) (*analytics.SpendingAnalysis, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSpendingAnalysisByUser", ctx, userID, startDate, endDate)
        ret0, _ := ret[0].(*analytics.SpendingAnalysis)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSpendingAnalysisByUser indicates an expected call of GetSpendingAnalysisByUser.
func (mr *MockRepositoryMockRecorder) GetSpendingAnalysisByUser(ctx, userID, startDate, endDate interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSpendingAnalysisByUser", reflect.TypeOf((*MockRepository)(nil).GetSpendingAnalysisByUser), ctx, userID, startDate, endDate)
}</span>

// GetTransactionsByPeriod mocks base method.
func (m *MockRepository) GetTransactionsByPeriod(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) ([]analytics.Transaction, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTransactionsByPeriod", ctx, userID, startDate, endDate)
        ret0, _ := ret[0].([]analytics.Transaction)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTransactionsByPeriod indicates an expected call of GetTransactionsByPeriod.
func (mr *MockRepositoryMockRecorder) GetTransactionsByPeriod(ctx, userID, startDate, endDate interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionsByPeriod", reflect.TypeOf((*MockRepository)(nil).GetTransactionsByPeriod), ctx, userID, startDate, endDate)
}</span>

// UpdateCategorizationRule mocks base method.
func (m *MockRepository) UpdateCategorizationRule(ctx context.Context, rule *analytics.CategorizationRule) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateCategorizationRule", ctx, rule)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateCategorizationRule indicates an expected call of UpdateCategorizationRule.
func (mr *MockRepositoryMockRecorder) UpdateCategorizationRule(ctx, rule interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCategorizationRule", reflect.TypeOf((*MockRepository)(nil).UpdateCategorizationRule), ctx, rule)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package mocks

import (
        "context"
        "time"

        "github.com/google/uuid"
        "github.com/stretchr/testify/mock"

        "fiscaflow/internal/domain/analytics"
)

// MockService is a mock of Service interface.
type MockService struct {
        mock.Mock
}

// CategorizeTransaction mocks base method.
func (m *MockService) CategorizeTransaction(ctx context.Context, req *analytics.CategorizationRequest) (*analytics.CategorizationResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, req)
        return args.Get(0).(*analytics.CategorizationResponse), args.Error(1)
}</span>

// CreateCategorizationRule mocks base method.
func (m *MockService) CreateCategorizationRule(ctx context.Context, req *analytics.CreateCategorizationRuleRequest) (*analytics.CategorizationRuleResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, req)
        return args.Get(0).(*analytics.CategorizationRuleResponse), args.Error(1)
}</span>

// GetCategorizationRule mocks base method.
func (m *MockService) GetCategorizationRule(ctx context.Context, id uuid.UUID) (*analytics.CategorizationRuleResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Get(0).(*analytics.CategorizationRuleResponse), args.Error(1)
}</span>

// ListCategorizationRules mocks base method.
func (m *MockService) ListCategorizationRules(ctx context.Context, offset, limit int) ([]analytics.CategorizationRuleResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, offset, limit)
        return args.Get(0).([]analytics.CategorizationRuleResponse), args.Error(1)
}</span>

// UpdateCategorizationRule mocks base method.
func (m *MockService) UpdateCategorizationRule(ctx context.Context, id uuid.UUID, req *analytics.UpdateCategorizationRuleRequest) (*analytics.CategorizationRuleResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id, req)
        return args.Get(0).(*analytics.CategorizationRuleResponse), args.Error(1)
}</span>

// DeleteCategorizationRule mocks base method.
func (m *MockService) DeleteCategorizationRule(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

// AnalyzeSpending mocks base method.
func (m *MockService) AnalyzeSpending(ctx context.Context, userID uuid.UUID, req *analytics.SpendingAnalysisRequest) (*analytics.SpendingAnalysisResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID, req)
        return args.Get(0).(*analytics.SpendingAnalysisResponse), args.Error(1)
}</span>

// GetSpendingInsights mocks base method.
func (m *MockService) GetSpendingInsights(ctx context.Context, userID uuid.UUID, periodStart, periodEnd time.Time) ([]analytics.SpendingInsight, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID, periodStart, periodEnd)
        return args.Get(0).([]analytics.SpendingInsight), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package analytics

import (
        "time"

        "github.com/google/uuid"
)

// CategorizationModel represents a machine learning model for transaction categorization
type CategorizationModel struct {
        ID        uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Name      string    `json:"name" gorm:"not null"`
        Version   string    `json:"version" gorm:"not null"`
        ModelType string    `json:"model_type" gorm:"not null"` // "keyword", "mlp", "transformer"
        Accuracy  float64   `json:"accuracy" gorm:"type:decimal(5,4)"`
        IsActive  bool      `json:"is_active" gorm:"default:true"`
        ModelData string    `json:"model_data" gorm:"type:jsonb"` // Serialized model
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// CategorizationRule represents a rule-based categorization rule
type CategorizationRule struct {
        ID          uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        CategoryID  uuid.UUID `json:"category_id" gorm:"type:uuid;not null"`
        Pattern     string    `json:"pattern" gorm:"not null"`      // Regex pattern or keyword
        PatternType string    `json:"pattern_type" gorm:"not null"` // "regex", "keyword", "exact"
        Priority    int       `json:"priority" gorm:"default:0"`
        IsActive    bool      `json:"is_active" gorm:"default:true"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// SpendingAnalysis represents spending analysis for a user
type SpendingAnalysis struct {
        ID                uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID            uuid.UUID `json:"user_id" gorm:"type:uuid;not null"`
        PeriodStart       time.Time `json:"period_start" gorm:"not null"`
        PeriodEnd         time.Time `json:"period_end" gorm:"not null"`
        TotalSpent        float64   `json:"total_spent" gorm:"type:decimal(15,2)"`
        TotalIncome       float64   `json:"total_income" gorm:"type:decimal(15,2)"`
        NetAmount         float64   `json:"net_amount" gorm:"type:decimal(15,2)"`
        CategoryBreakdown string    `json:"category_breakdown" gorm:"type:jsonb"`
        TopCategories     string    `json:"top_categories" gorm:"type:jsonb"`
        SpendingTrends    string    `json:"spending_trends" gorm:"type:jsonb"`
        CreatedAt         time.Time `json:"created_at"`
        UpdatedAt         time.Time `json:"updated_at"`
}

// CategorizationRequest represents a request to categorize a transaction
type CategorizationRequest struct {
        Description string  `json:"description" binding:"required"`
        Merchant    string  `json:"merchant"`
        Amount      float64 `json:"amount"`
        Location    string  `json:"location"`
}

// CategorizationResponse represents the categorization result
type CategorizationResponse struct {
        CategoryID            uuid.UUID            `json:"category_id"`
        CategoryName          string               `json:"category_name"`
        Confidence            float64              `json:"confidence"`
        CategorizationSource  string               `json:"categorization_source"` // "rule", "ml", "manual"
        MatchedPattern        string               `json:"matched_pattern,omitempty"`
        AlternativeCategories []CategorySuggestion `json:"alternative_categories,omitempty"`
}

// CategorySuggestion represents a suggested category with confidence
type CategorySuggestion struct {
        CategoryID   uuid.UUID `json:"category_id"`
        CategoryName string    `json:"category_name"`
        Confidence   float64   `json:"confidence"`
        Reason       string    `json:"reason"`
}

// SpendingInsight represents a spending insight
type SpendingInsight struct {
        Type        string                 `json:"type"` // "trend", "anomaly", "pattern", "recommendation"
        Title       string                 `json:"title"`
        Description string                 `json:"description"`
        Severity    string                 `json:"severity"` // "low", "medium", "high"
        Data        map[string]interface{} `json:"data"`
        CreatedAt   time.Time              `json:"created_at"`
}

// CreateCategorizationRuleRequest represents a request to create a categorization rule
type CreateCategorizationRuleRequest struct {
        CategoryID  uuid.UUID `json:"category_id" binding:"required"`
        Pattern     string    `json:"pattern" binding:"required"`
        PatternType string    `json:"pattern_type" binding:"required"`
        Priority    int       `json:"priority"`
}

// UpdateCategorizationRuleRequest represents a request to update a categorization rule
type UpdateCategorizationRuleRequest struct {
        Pattern     *string `json:"pattern"`
        PatternType *string `json:"pattern_type"`
        Priority    *int    `json:"priority"`
        IsActive    *bool   `json:"is_active"`
}

// CategorizationRuleResponse represents a categorization rule response
type CategorizationRuleResponse struct {
        ID           uuid.UUID `json:"id"`
        CategoryID   uuid.UUID `json:"category_id"`
        CategoryName string    `json:"category_name"`
        Pattern      string    `json:"pattern"`
        PatternType  string    `json:"pattern_type"`
        Priority     int       `json:"priority"`
        IsActive     bool      `json:"is_active"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

// SpendingAnalysisRequest represents a request for spending analysis
type SpendingAnalysisRequest struct {
        StartDate time.Time `json:"start_date" binding:"required"`
        EndDate   time.Time `json:"end_date" binding:"required"`
        GroupBy   string    `json:"group_by"` // "day", "week", "month", "category"
}

// SpendingAnalysisResponse represents a spending analysis response
type SpendingAnalysisResponse struct {
        PeriodStart       time.Time          `json:"period_start"`
        PeriodEnd         time.Time          `json:"period_end"`
        TotalSpent        float64            `json:"total_spent"`
        TotalIncome       float64            `json:"total_income"`
        NetAmount         float64            `json:"net_amount"`
        CategoryBreakdown []CategorySpending `json:"category_breakdown"`
        TopCategories     []CategorySpending `json:"top_categories"`
        SpendingTrends    []SpendingTrend    `json:"spending_trends"`
        Insights          []SpendingInsight  `json:"insights"`
}

// CategorySpending represents spending for a category
type CategorySpending struct {
        CategoryID       uuid.UUID `json:"category_id"`
        CategoryName     string    `json:"category_name"`
        Amount           float64   `json:"amount"`
        Percentage       float64   `json:"percentage"`
        TransactionCount int       `json:"transaction_count"`
}

// SpendingTrend represents a spending trend
type SpendingTrend struct {
        Period string  `json:"period"`
        Amount float64 `json:"amount"`
        Change float64 `json:"change"` // Percentage change from previous period
        Trend  string  `json:"trend"`  // "increasing", "decreasing", "stable"
}

// TableName specifies the table name for CategorizationModel
func (CategorizationModel) TableName() string <span class="cov0" title="0">{
        return "categorization_models"
}</span>

// TableName specifies the table name for CategorizationRule
func (CategorizationRule) TableName() string <span class="cov0" title="0">{
        return "categorization_rules"
}</span>

// TableName specifies the table name for SpendingAnalysis
func (SpendingAnalysis) TableName() string <span class="cov0" title="0">{
        return "spending_analyses"
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package analytics

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository defines the interface for analytics data access
type Repository interface {
        // Categorization rule operations
        CreateCategorizationRule(ctx context.Context, rule *CategorizationRule) error
        GetCategorizationRuleByID(ctx context.Context, id uuid.UUID) (*CategorizationRule, error)
        GetCategorizationRules(ctx context.Context, offset, limit int) ([]CategorizationRule, error)
        GetActiveCategorizationRules(ctx context.Context) ([]CategorizationRule, error)
        UpdateCategorizationRule(ctx context.Context, rule *CategorizationRule) error
        DeleteCategorizationRule(ctx context.Context, id uuid.UUID) error

        // Category operations
        GetCategoryByID(ctx context.Context, id uuid.UUID) (*Category, error)

        // Transaction operations for ML
        GetSimilarTransactions(ctx context.Context, description string, limit int) ([]Transaction, error)
        GetTransactionsByPeriod(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) ([]Transaction, error)

        // Spending analysis operations
        CreateSpendingAnalysis(ctx context.Context, analysis *SpendingAnalysis) error
        GetSpendingAnalysisByID(ctx context.Context, id uuid.UUID) (*SpendingAnalysis, error)
        GetSpendingAnalysisByUser(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) (*SpendingAnalysis, error)
}

// repository implements the Repository interface
type repository struct {
        db *gorm.DB
}

// NewRepository creates a new analytics repository
func NewRepository(db *gorm.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// CreateCategorizationRule creates a new categorization rule
func (r *repository) CreateCategorizationRule(ctx context.Context, rule *CategorizationRule) error <span class="cov0" title="0">{
        rule.CreatedAt = time.Now()
        rule.UpdatedAt = time.Now()

        return r.db.WithContext(ctx).Create(rule).Error
}</span>

// GetCategorizationRuleByID retrieves a categorization rule by ID
func (r *repository) GetCategorizationRuleByID(ctx context.Context, id uuid.UUID) (*CategorizationRule, error) <span class="cov0" title="0">{
        var rule CategorizationRule
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;rule).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("categorization rule not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get categorization rule: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;rule, nil</span>
}

// GetCategorizationRules retrieves categorization rules with pagination
func (r *repository) GetCategorizationRules(ctx context.Context, offset, limit int) ([]CategorizationRule, error) <span class="cov0" title="0">{
        var rules []CategorizationRule
        err := r.db.WithContext(ctx).
                Order("priority DESC, created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;rules).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get categorization rules: %w", err)
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

// GetActiveCategorizationRules retrieves all active categorization rules
func (r *repository) GetActiveCategorizationRules(ctx context.Context) ([]CategorizationRule, error) <span class="cov0" title="0">{
        var rules []CategorizationRule
        err := r.db.WithContext(ctx).
                Where("is_active = ?", true).
                Order("priority DESC, created_at DESC").
                Find(&amp;rules).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active categorization rules: %w", err)
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

// UpdateCategorizationRule updates a categorization rule
func (r *repository) UpdateCategorizationRule(ctx context.Context, rule *CategorizationRule) error <span class="cov0" title="0">{
        rule.UpdatedAt = time.Now()

        result := r.db.WithContext(ctx).Save(rule)
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update categorization rule: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("categorization rule not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteCategorizationRule deletes a categorization rule
func (r *repository) DeleteCategorizationRule(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;CategorizationRule{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete categorization rule: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("categorization rule not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetCategoryByID retrieves a category by ID
func (r *repository) GetCategoryByID(ctx context.Context, id uuid.UUID) (*Category, error) <span class="cov0" title="0">{
        var category Category
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;category).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("category not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get category: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;category, nil</span>
}

// GetSimilarTransactions retrieves transactions similar to the given description
func (r *repository) GetSimilarTransactions(ctx context.Context, description string, limit int) ([]Transaction, error) <span class="cov0" title="0">{
        var transactions []Transaction

        // Simple similarity search using LIKE
        searchTerm := "%" + description + "%"

        err := r.db.WithContext(ctx).
                Where("description ILIKE ? OR merchant ILIKE ?", searchTerm, searchTerm).
                Order("created_at DESC").
                Limit(limit).
                Find(&amp;transactions).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get similar transactions: %w", err)
        }</span>

        <span class="cov0" title="0">return transactions, nil</span>
}

// GetTransactionsByPeriod retrieves transactions for a user within a date range
func (r *repository) GetTransactionsByPeriod(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) ([]Transaction, error) <span class="cov0" title="0">{
        var transactions []Transaction

        err := r.db.WithContext(ctx).
                Where("user_id = ? AND transaction_date &gt;= ? AND transaction_date &lt;= ?", userID, startDate, endDate).
                Order("transaction_date DESC").
                Find(&amp;transactions).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transactions by period: %w", err)
        }</span>

        <span class="cov0" title="0">return transactions, nil</span>
}

// CreateSpendingAnalysis creates a new spending analysis
func (r *repository) CreateSpendingAnalysis(ctx context.Context, analysis *SpendingAnalysis) error <span class="cov0" title="0">{
        analysis.CreatedAt = time.Now()
        analysis.UpdatedAt = time.Now()

        return r.db.WithContext(ctx).Create(analysis).Error
}</span>

// GetSpendingAnalysisByID retrieves a spending analysis by ID
func (r *repository) GetSpendingAnalysisByID(ctx context.Context, id uuid.UUID) (*SpendingAnalysis, error) <span class="cov0" title="0">{
        var analysis SpendingAnalysis
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;analysis).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("spending analysis not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get spending analysis: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;analysis, nil</span>
}

// GetSpendingAnalysisByUser retrieves spending analysis for a user within a date range
func (r *repository) GetSpendingAnalysisByUser(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) (*SpendingAnalysis, error) <span class="cov0" title="0">{
        var analysis SpendingAnalysis
        err := r.db.WithContext(ctx).
                Where("user_id = ? AND period_start &gt;= ? AND period_end &lt;= ?", userID, startDate, endDate).
                Order("created_at DESC").
                First(&amp;analysis).Error

        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("spending analysis not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get spending analysis: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;analysis, nil</span>
}

// Category represents a transaction category (imported from transaction domain)
type Category struct {
        ID          uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Name        string     `json:"name" gorm:"not null"`
        Description string     `json:"description"`
        Icon        string     `json:"icon"`
        Color       string     `json:"color"`
        ParentID    *uuid.UUID `json:"parent_id" gorm:"type:uuid"`
        IsDefault   bool       `json:"is_default" gorm:"default:false"`
        IsActive    bool       `json:"is_active" gorm:"default:true"`
        SortOrder   int        `json:"sort_order" gorm:"default:0"`
        CreatedAt   time.Time  `json:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at"`
}

// Transaction represents a transaction (imported from transaction domain)
type Transaction struct {
        ID         uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID     uuid.UUID  `json:"user_id" gorm:"type:uuid;not null"`
        FamilyID   *uuid.UUID `json:"family_id" gorm:"type:uuid"`
        AccountID  uuid.UUID  `json:"account_id" gorm:"type:uuid;not null"`
        CategoryID *uuid.UUID `json:"category_id" gorm:"type:uuid"`

        Amount      float64 `json:"amount" gorm:"type:decimal(15,2);not null"`
        Currency    string  `json:"currency" gorm:"default:'USD'"`
        Description string  `json:"description" gorm:"not null"`
        Merchant    string  `json:"merchant"`
        Location    string  `json:"location" gorm:"type:jsonb"`

        TransactionDate time.Time  `json:"transaction_date" gorm:"not null"`
        PostedDate      *time.Time `json:"posted_date"`
        Status          string     `json:"status" gorm:"default:'pending'"`

        CategorizationSource     string   `json:"categorization_source" gorm:"default:'manual'"`
        CategorizationConfidence *float64 `json:"categorization_confidence"`

        Tags       []string `json:"tags" gorm:"type:text[]"`
        Notes      string   `json:"notes"`
        ReceiptURL string   `json:"receipt_url"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// TableName specifies the table name for Category
func (Category) TableName() string <span class="cov0" title="0">{
        return "categories"
}</span>

// TableName specifies the table name for Transaction
func (Transaction) TableName() string <span class="cov0" title="0">{
        return "transactions"
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package analytics

import (
        "context"
        "fmt"
        "math"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// Service defines the interface for analytics business logic
type Service interface {
        // Categorization operations
        CategorizeTransaction(ctx context.Context, req *CategorizationRequest) (*CategorizationResponse, error)
        CreateCategorizationRule(ctx context.Context, req *CreateCategorizationRuleRequest) (*CategorizationRuleResponse, error)
        GetCategorizationRule(ctx context.Context, id uuid.UUID) (*CategorizationRuleResponse, error)
        ListCategorizationRules(ctx context.Context, offset, limit int) ([]CategorizationRuleResponse, error)
        UpdateCategorizationRule(ctx context.Context, id uuid.UUID, req *UpdateCategorizationRuleRequest) (*CategorizationRuleResponse, error)
        DeleteCategorizationRule(ctx context.Context, id uuid.UUID) error

        // Spending analysis operations
        AnalyzeSpending(ctx context.Context, userID uuid.UUID, req *SpendingAnalysisRequest) (*SpendingAnalysisResponse, error)
        GetSpendingInsights(ctx context.Context, userID uuid.UUID, periodStart, periodEnd time.Time) ([]SpendingInsight, error)
}

// service implements the Service interface
type service struct {
        repo Repository
}

// NewService creates a new analytics service
func NewService(repo Repository) Service <span class="cov10" title="2">{
        return &amp;service{repo: repo}
}</span>

// CategorizeTransaction categorizes a transaction using rule-based and ML approaches
func (s *service) CategorizeTransaction(ctx context.Context, req *CategorizationRequest) (*CategorizationResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.CategorizeTransaction",
                trace.WithAttributes(
                        attribute.String("description", req.Description),
                        attribute.String("merchant", req.Merchant),
                        attribute.Float64("amount", req.Amount),
                ),
        )
        defer span.End()

        // First, try rule-based categorization
        ruleMatch, err := s.categorizeByRules(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, fmt.Errorf("failed to categorize by rules: %w", err)
        }</span>

        <span class="cov1" title="1">if ruleMatch != nil &amp;&amp; ruleMatch.Confidence &gt; 0.8 </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("category_id", ruleMatch.CategoryID.String()),
                        attribute.Float64("confidence", ruleMatch.Confidence),
                        attribute.String("source", "rule"),
                )
                return ruleMatch, nil
        }</span>

        // If no high-confidence rule match, try ML-based categorization
        <span class="cov0" title="0">mlMatch, err := s.categorizeByML(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, fmt.Errorf("failed to categorize by ML: %w", err)
        }</span>

        <span class="cov0" title="0">if mlMatch != nil </span><span class="cov0" title="0">{
                span.SetAttributes(
                        attribute.String("category_id", mlMatch.CategoryID.String()),
                        attribute.Float64("confidence", mlMatch.Confidence),
                        attribute.String("source", "ml"),
                )
                return mlMatch, nil
        }</span>

        // If no categorization found, return a default response
        <span class="cov0" title="0">defaultResponse := &amp;CategorizationResponse{
                CategoryID:           uuid.Nil,
                CategoryName:         "Uncategorized",
                Confidence:           0.0,
                CategorizationSource: "manual",
        }

        span.SetAttributes(
                attribute.String("category_id", "uncategorized"),
                attribute.Float64("confidence", 0.0),
                attribute.String("source", "manual"),
        )

        return defaultResponse, nil</span>
}

// categorizeByRules categorizes a transaction using rule-based matching
func (s *service) categorizeByRules(ctx context.Context, req *CategorizationRequest) (*CategorizationResponse, error) <span class="cov1" title="1">{
        rules, err := s.repo.GetActiveCategorizationRules(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort rules by priority (higher priority first)
        <span class="cov1" title="1">sort.Slice(rules, func(i, j int) bool </span><span class="cov0" title="0">{
                return rules[i].Priority &gt; rules[j].Priority
        }</span>)

        <span class="cov1" title="1">text := strings.ToLower(req.Description)
        if req.Merchant != "" </span><span class="cov1" title="1">{
                text += " " + strings.ToLower(req.Merchant)
        }</span>

        <span class="cov1" title="1">for _, rule := range rules </span><span class="cov1" title="1">{
                if !rule.IsActive </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">var matched bool
                switch rule.PatternType </span>{
                case "exact":<span class="cov0" title="0">
                        matched = strings.Contains(text, strings.ToLower(rule.Pattern))</span>
                case "keyword":<span class="cov1" title="1">
                        keywords := strings.Split(strings.ToLower(rule.Pattern), " ")
                        matched = true
                        for _, keyword := range keywords </span><span class="cov1" title="1">{
                                if !strings.Contains(text, keyword) </span><span class="cov0" title="0">{
                                        matched = false
                                        break</span>
                                }
                        }
                case "regex":<span class="cov0" title="0">
                        re, err := regexp.Compile(strings.ToLower(rule.Pattern))
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip invalid regex
                        }
                        <span class="cov0" title="0">matched = re.MatchString(text)</span>
                }

                <span class="cov1" title="1">if matched </span><span class="cov1" title="1">{
                        // Get category name
                        category, err := s.repo.GetCategoryByID(ctx, rule.CategoryID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="1">confidence := s.calculateRuleConfidence(&amp;rule, req.Amount)

                        return &amp;CategorizationResponse{
                                CategoryID:           rule.CategoryID,
                                CategoryName:         category.Name,
                                Confidence:           confidence,
                                CategorizationSource: "rule",
                                MatchedPattern:       rule.Pattern,
                        }, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// categorizeByML categorizes a transaction using simple ML (keyword frequency analysis)
func (s *service) categorizeByML(ctx context.Context, req *CategorizationRequest) (*CategorizationResponse, error) <span class="cov0" title="0">{
        // Simple ML approach: keyword frequency analysis based on historical data
        // In a real implementation, this would use a trained model

        text := strings.ToLower(req.Description)
        if req.Merchant != "" </span><span class="cov0" title="0">{
                text += " " + strings.ToLower(req.Merchant)
        }</span>

        // Get historical categorization data for similar transactions
        <span class="cov0" title="0">similarTransactions, err := s.repo.GetSimilarTransactions(ctx, text, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(similarTransactions) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Count category frequencies
        <span class="cov0" title="0">categoryCounts := make(map[uuid.UUID]int)
        totalCount := 0

        for _, tx := range similarTransactions </span><span class="cov0" title="0">{
                if tx.CategoryID != nil </span><span class="cov0" title="0">{
                        categoryCounts[*tx.CategoryID]++
                        totalCount++
                }</span>
        }

        <span class="cov0" title="0">if totalCount == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Find the most common category
        <span class="cov0" title="0">var bestCategoryID uuid.UUID
        var bestCount int

        for categoryID, count := range categoryCounts </span><span class="cov0" title="0">{
                if count &gt; bestCount </span><span class="cov0" title="0">{
                        bestCategoryID = categoryID
                        bestCount = count
                }</span>
        }

        <span class="cov0" title="0">if bestCount == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Calculate confidence based on frequency
        <span class="cov0" title="0">confidence := float64(bestCount) / float64(totalCount)

        // Adjust confidence based on amount similarity
        amountSimilarity := s.calculateAmountSimilarity(req.Amount, similarTransactions)
        confidence = (confidence + amountSimilarity) / 2

        // Get category name
        category, err := s.repo.GetCategoryByID(ctx, bestCategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;CategorizationResponse{
                CategoryID:           bestCategoryID,
                CategoryName:         category.Name,
                Confidence:           confidence,
                CategorizationSource: "ml",
        }, nil</span>
}

// calculateRuleConfidence calculates confidence for rule-based categorization
func (s *service) calculateRuleConfidence(rule *CategorizationRule, amount float64) float64 <span class="cov1" title="1">{
        baseConfidence := 0.8

        // Adjust confidence based on pattern type
        switch rule.PatternType </span>{
        case "exact":<span class="cov0" title="0">
                baseConfidence = 0.9</span>
        case "keyword":<span class="cov1" title="1">
                baseConfidence = 0.85</span>
        case "regex":<span class="cov0" title="0">
                baseConfidence = 0.8</span>
        }

        // Adjust confidence based on amount (if amount is typical for the category)
        // This is a simplified approach - in reality, you'd have historical data
        <span class="cov1" title="1">if amount &gt; 0 &amp;&amp; amount &lt; 1000 </span><span class="cov1" title="1">{
                baseConfidence += 0.05
        }</span>

        <span class="cov1" title="1">return math.Min(baseConfidence, 1.0)</span>
}

// calculateAmountSimilarity calculates similarity based on transaction amounts
func (s *service) calculateAmountSimilarity(amount float64, transactions []Transaction) float64 <span class="cov0" title="0">{
        if len(transactions) == 0 </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        // Calculate average amount
        <span class="cov0" title="0">var totalAmount float64
        var count int
        for _, tx := range transactions </span><span class="cov0" title="0">{
                totalAmount += tx.Amount
                count++
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov0" title="0">avgAmount := totalAmount / float64(count)

        // Calculate similarity based on how close the amount is to the average
        diff := math.Abs(amount - avgAmount)
        similarity := 1.0 - (diff / avgAmount)

        return math.Max(0.0, math.Min(1.0, similarity))</span>
}

// CreateCategorizationRule creates a new categorization rule
func (s *service) CreateCategorizationRule(ctx context.Context, req *CreateCategorizationRuleRequest) (*CategorizationRuleResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.CreateCategorizationRule",
                trace.WithAttributes(
                        attribute.String("category_id", req.CategoryID.String()),
                        attribute.String("pattern", req.Pattern),
                        attribute.String("pattern_type", req.PatternType),
                ),
        )
        defer span.End()

        // Validate pattern
        if err := s.validatePattern(req.Pattern, req.PatternType); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">rule := &amp;CategorizationRule{
                CategoryID:  req.CategoryID,
                Pattern:     req.Pattern,
                PatternType: req.PatternType,
                Priority:    req.Priority,
                IsActive:    true,
        }

        if err := s.repo.CreateCategorizationRule(ctx, rule); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String("rule_id", rule.ID.String()))
        return s.toCategorizationRuleResponse(rule), nil</span>
}

// GetCategorizationRule retrieves a categorization rule
func (s *service) GetCategorizationRule(ctx context.Context, id uuid.UUID) (*CategorizationRuleResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.GetCategorizationRule",
                trace.WithAttributes(attribute.String("rule_id", id.String())),
        )
        defer span.End()

        rule, err := s.repo.GetCategorizationRuleByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toCategorizationRuleResponse(rule), nil</span>
}

// ListCategorizationRules retrieves categorization rules
func (s *service) ListCategorizationRules(ctx context.Context, offset, limit int) ([]CategorizationRuleResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.ListCategorizationRules",
                trace.WithAttributes(
                        attribute.Int("offset", offset),
                        attribute.Int("limit", limit),
                ),
        )
        defer span.End()

        rules, err := s.repo.GetCategorizationRules(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">responses := make([]CategorizationRuleResponse, len(rules))
        for i, rule := range rules </span><span class="cov0" title="0">{
                responses[i] = *s.toCategorizationRuleResponse(&amp;rule)
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.Int("rules_count", len(responses)))
        return responses, nil</span>
}

// UpdateCategorizationRule updates a categorization rule
func (s *service) UpdateCategorizationRule(ctx context.Context, id uuid.UUID, req *UpdateCategorizationRuleRequest) (*CategorizationRuleResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.UpdateCategorizationRule",
                trace.WithAttributes(attribute.String("rule_id", id.String())),
        )
        defer span.End()

        rule, err := s.repo.GetCategorizationRuleByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.Pattern != nil </span><span class="cov0" title="0">{
                rule.Pattern = *req.Pattern
        }</span>
        <span class="cov0" title="0">if req.PatternType != nil </span><span class="cov0" title="0">{
                rule.PatternType = *req.PatternType
        }</span>
        <span class="cov0" title="0">if req.Priority != nil </span><span class="cov0" title="0">{
                rule.Priority = *req.Priority
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                rule.IsActive = *req.IsActive
        }</span>

        // Validate pattern if updated
        <span class="cov0" title="0">if req.Pattern != nil || req.PatternType != nil </span><span class="cov0" title="0">{
                if err := s.validatePattern(rule.Pattern, rule.PatternType); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, err.Error())
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := s.repo.UpdateCategorizationRule(ctx, rule); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toCategorizationRuleResponse(rule), nil</span>
}

// DeleteCategorizationRule deletes a categorization rule
func (s *service) DeleteCategorizationRule(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.DeleteCategorizationRule",
                trace.WithAttributes(attribute.String("rule_id", id.String())),
        )
        defer span.End()

        if err := s.repo.DeleteCategorizationRule(ctx, id); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AnalyzeSpending analyzes spending for a user
func (s *service) AnalyzeSpending(ctx context.Context, userID uuid.UUID, req *SpendingAnalysisRequest) (*SpendingAnalysisResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.AnalyzeSpending",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("start_date", req.StartDate.Format("2006-01-02")),
                        attribute.String("end_date", req.EndDate.Format("2006-01-02")),
                ),
        )
        defer span.End()

        // Get transactions for the period
        transactions, err := s.repo.GetTransactionsByPeriod(ctx, userID, req.StartDate, req.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Calculate basic metrics
        <span class="cov0" title="0">var totalSpent, totalIncome float64
        categorySpending := make(map[uuid.UUID]*CategorySpending)

        for _, tx := range transactions </span><span class="cov0" title="0">{
                if tx.Amount &lt; 0 </span><span class="cov0" title="0">{
                        totalSpent += math.Abs(tx.Amount)
                }</span> else<span class="cov0" title="0"> {
                        totalIncome += tx.Amount
                }</span>

                <span class="cov0" title="0">if tx.CategoryID != nil </span><span class="cov0" title="0">{
                        if spending, exists := categorySpending[*tx.CategoryID]; exists </span><span class="cov0" title="0">{
                                spending.Amount += math.Abs(tx.Amount)
                                spending.TransactionCount++
                        }</span> else<span class="cov0" title="0"> {
                                category, _ := s.repo.GetCategoryByID(ctx, *tx.CategoryID)
                                categoryName := "Uncategorized"
                                if category != nil </span><span class="cov0" title="0">{
                                        categoryName = category.Name
                                }</span>

                                <span class="cov0" title="0">categorySpending[*tx.CategoryID] = &amp;CategorySpending{
                                        CategoryID:       *tx.CategoryID,
                                        CategoryName:     categoryName,
                                        Amount:           math.Abs(tx.Amount),
                                        TransactionCount: 1,
                                }</span>
                        }
                }
        }

        // Calculate percentages
        <span class="cov0" title="0">for _, spending := range categorySpending </span><span class="cov0" title="0">{
                if totalSpent &gt; 0 </span><span class="cov0" title="0">{
                        spending.Percentage = (spending.Amount / totalSpent) * 100
                }</span>
        }

        // Get top categories
        <span class="cov0" title="0">topCategories := s.getTopCategories(categorySpending, 5)

        // Generate spending trends
        spendingTrends := s.generateSpendingTrends(transactions, req.GroupBy)

        // Generate insights
        insights := s.generateSpendingInsights(transactions, categorySpending, totalSpent, totalIncome)

        response := &amp;SpendingAnalysisResponse{
                PeriodStart:       req.StartDate,
                PeriodEnd:         req.EndDate,
                TotalSpent:        totalSpent,
                TotalIncome:       totalIncome,
                NetAmount:         totalIncome - totalSpent,
                CategoryBreakdown: s.mapToSlice(categorySpending),
                TopCategories:     topCategories,
                SpendingTrends:    spendingTrends,
                Insights:          insights,
        }

        span.SetAttributes(
                attribute.Float64("total_spent", totalSpent),
                attribute.Float64("total_income", totalIncome),
                attribute.Int("insights_count", len(insights)),
        )

        return response, nil</span>
}

// GetSpendingInsights generates spending insights for a user
func (s *service) GetSpendingInsights(ctx context.Context, userID uuid.UUID, periodStart, periodEnd time.Time) ([]SpendingInsight, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "analytics.GetSpendingInsights",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("period_start", periodStart.Format("2006-01-02")),
                        attribute.String("period_end", periodEnd.Format("2006-01-02")),
                ),
        )
        defer span.End()

        // Get transactions for the period
        transactions, err := s.repo.GetTransactionsByPeriod(ctx, userID, periodStart, periodEnd)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Calculate category spending
        <span class="cov0" title="0">categorySpending := make(map[uuid.UUID]*CategorySpending)
        var totalSpent, totalIncome float64

        for _, tx := range transactions </span><span class="cov0" title="0">{
                if tx.Amount &lt; 0 </span><span class="cov0" title="0">{
                        totalSpent += math.Abs(tx.Amount)
                }</span> else<span class="cov0" title="0"> {
                        totalIncome += tx.Amount
                }</span>

                <span class="cov0" title="0">if tx.CategoryID != nil </span><span class="cov0" title="0">{
                        if spending, exists := categorySpending[*tx.CategoryID]; exists </span><span class="cov0" title="0">{
                                spending.Amount += math.Abs(tx.Amount)
                                spending.TransactionCount++
                        }</span> else<span class="cov0" title="0"> {
                                category, _ := s.repo.GetCategoryByID(ctx, *tx.CategoryID)
                                categoryName := "Uncategorized"
                                if category != nil </span><span class="cov0" title="0">{
                                        categoryName = category.Name
                                }</span>

                                <span class="cov0" title="0">categorySpending[*tx.CategoryID] = &amp;CategorySpending{
                                        CategoryID:       *tx.CategoryID,
                                        CategoryName:     categoryName,
                                        Amount:           math.Abs(tx.Amount),
                                        TransactionCount: 1,
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">insights := s.generateSpendingInsights(transactions, categorySpending, totalSpent, totalIncome)

        span.SetAttributes(attribute.Int("insights_count", len(insights)))
        return insights, nil</span>
}

// Helper methods

func (s *service) validatePattern(pattern, patternType string) error <span class="cov0" title="0">{
        switch patternType </span>{
        case "exact", "keyword":<span class="cov0" title="0">
                if pattern == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("pattern cannot be empty")
                }</span>
        case "regex":<span class="cov0" title="0">
                if _, err := regexp.Compile(pattern); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid regex pattern: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid pattern type: %s", patternType)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *service) getTopCategories(categorySpending map[uuid.UUID]*CategorySpending, limit int) []CategorySpending <span class="cov0" title="0">{
        // Convert map to slice
        categories := make([]CategorySpending, 0, len(categorySpending))
        for _, spending := range categorySpending </span><span class="cov0" title="0">{
                categories = append(categories, *spending)
        }</span>

        // Sort by amount (descending)
        <span class="cov0" title="0">sort.Slice(categories, func(i, j int) bool </span><span class="cov0" title="0">{
                return categories[i].Amount &gt; categories[j].Amount
        }</span>)

        // Return top N categories
        <span class="cov0" title="0">if len(categories) &gt; limit </span><span class="cov0" title="0">{
                return categories[:limit]
        }</span>
        <span class="cov0" title="0">return categories</span>
}

func (s *service) generateSpendingTrends(transactions []Transaction, groupBy string) []SpendingTrend <span class="cov0" title="0">{
        // Simplified trend generation
        // In a real implementation, this would analyze historical data

        trends := []SpendingTrend{
                {
                        Period: "Week 1",
                        Amount: 500.0,
                        Change: 0.0,
                        Trend:  "stable",
                },
                {
                        Period: "Week 2",
                        Amount: 550.0,
                        Change: 10.0,
                        Trend:  "increasing",
                },
                {
                        Period: "Week 3",
                        Amount: 480.0,
                        Change: -12.7,
                        Trend:  "decreasing",
                },
        }

        return trends
}</span>

func (s *service) generateSpendingInsights(transactions []Transaction, categorySpending map[uuid.UUID]*CategorySpending, totalSpent, totalIncome float64) []SpendingInsight <span class="cov0" title="0">{
        var insights []SpendingInsight

        // High spending category insight
        var highestSpending *CategorySpending
        var highestAmount float64

        for _, spending := range categorySpending </span><span class="cov0" title="0">{
                if spending.Amount &gt; highestAmount </span><span class="cov0" title="0">{
                        highestAmount = spending.Amount
                        highestSpending = spending
                }</span>
        }

        <span class="cov0" title="0">if highestSpending != nil &amp;&amp; highestSpending.Percentage &gt; 30 </span><span class="cov0" title="0">{
                insights = append(insights, SpendingInsight{
                        Type:        "pattern",
                        Title:       "High Spending Category",
                        Description: fmt.Sprintf("You're spending %.1f%% of your budget on %s", highestSpending.Percentage, highestSpending.CategoryName),
                        Severity:    "medium",
                        Data: map[string]interface{}{
                                "category_id":   highestSpending.CategoryID.String(),
                                "category_name": highestSpending.CategoryName,
                                "percentage":    highestSpending.Percentage,
                                "amount":        highestSpending.Amount,
                        },
                        CreatedAt: time.Now(),
                })
        }</span>

        // Spending vs Income insight
        <span class="cov0" title="0">if totalIncome &gt; 0 </span><span class="cov0" title="0">{
                spendingRatio := totalSpent / totalIncome
                if spendingRatio &gt; 0.9 </span><span class="cov0" title="0">{
                        insights = append(insights, SpendingInsight{
                                Type:        "trend",
                                Title:       "High Spending Ratio",
                                Description: fmt.Sprintf("You're spending %.1f%% of your income", spendingRatio*100),
                                Severity:    "high",
                                Data: map[string]interface{}{
                                        "spending_ratio": spendingRatio,
                                        "total_spent":    totalSpent,
                                        "total_income":   totalIncome,
                                },
                                CreatedAt: time.Now(),
                        })
                }</span>
        }

        // Transaction frequency insight
        <span class="cov0" title="0">if len(transactions) &gt; 50 </span><span class="cov0" title="0">{
                insights = append(insights, SpendingInsight{
                        Type:        "pattern",
                        Title:       "High Transaction Frequency",
                        Description: fmt.Sprintf("You have %d transactions in this period", len(transactions)),
                        Severity:    "low",
                        Data: map[string]interface{}{
                                "transaction_count": len(transactions),
                        },
                        CreatedAt: time.Now(),
                })
        }</span>

        <span class="cov0" title="0">return insights</span>
}

func (s *service) mapToSlice(categorySpending map[uuid.UUID]*CategorySpending) []CategorySpending <span class="cov0" title="0">{
        result := make([]CategorySpending, 0, len(categorySpending))
        for _, spending := range categorySpending </span><span class="cov0" title="0">{
                result = append(result, *spending)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *service) toCategorizationRuleResponse(rule *CategorizationRule) *CategorizationRuleResponse <span class="cov0" title="0">{
        // Get category name
        category, _ := s.repo.GetCategoryByID(context.Background(), rule.CategoryID)
        categoryName := "Unknown"
        if category != nil </span><span class="cov0" title="0">{
                categoryName = category.Name
        }</span>

        <span class="cov0" title="0">return &amp;CategorizationRuleResponse{
                ID:           rule.ID,
                CategoryID:   rule.CategoryID,
                CategoryName: categoryName,
                Pattern:      rule.Pattern,
                PatternType:  rule.PatternType,
                Priority:     rule.Priority,
                IsActive:     rule.IsActive,
                CreatedAt:    rule.CreatedAt,
                UpdatedAt:    rule.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"

        "fiscaflow/internal/domain/budget"
)

// MockService is a mock of Service interface.
type MockService struct {
        mock.Mock
}

// CreateBudget mocks base method.
func (m *MockService) CreateBudget(ctx context.Context, userID string, req *budget.CreateBudgetRequest) (*budget.Budget, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID, req)
        return args.Get(0).(*budget.Budget), args.Error(1)
}</span>

// GetBudget mocks base method.
func (m *MockService) GetBudget(ctx context.Context, budgetID, userID string) (*budget.Budget, error) <span class="cov0" title="0">{
        args := m.Called(ctx, budgetID, userID)
        return args.Get(0).(*budget.Budget), args.Error(1)
}</span>

// ListBudgets mocks base method.
func (m *MockService) ListBudgets(ctx context.Context, userID string) ([]*budget.Budget, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        return args.Get(0).([]*budget.Budget), args.Error(1)
}</span>

// UpdateBudget mocks base method.
func (m *MockService) UpdateBudget(ctx context.Context, budgetID, userID string, req *budget.UpdateBudgetRequest) (*budget.Budget, error) <span class="cov0" title="0">{
        args := m.Called(ctx, budgetID, userID, req)
        return args.Get(0).(*budget.Budget), args.Error(1)
}</span>

// DeleteBudget mocks base method.
func (m *MockService) DeleteBudget(ctx context.Context, budgetID, userID string) error <span class="cov0" title="0">{
        args := m.Called(ctx, budgetID, userID)
        return args.Error(0)
}</span>

// GetBudgetSummary mocks base method.
func (m *MockService) GetBudgetSummary(ctx context.Context, budgetID, userID string) (*budget.BudgetSummary, error) <span class="cov0" title="0">{
        args := m.Called(ctx, budgetID, userID)
        return args.Get(0).(*budget.BudgetSummary), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package budget

import (
        "time"

        "github.com/google/uuid"
)

// Budget represents a user's budget
type Budget struct {
        ID          uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID      uuid.UUID  `json:"user_id" gorm:"type:uuid;not null"`
        FamilyID    *uuid.UUID `json:"family_id" gorm:"type:uuid"`
        Name        string     `json:"name" gorm:"not null"`
        Description string     `json:"description"`

        PeriodType PeriodType `json:"period_type" gorm:"not null"`
        StartDate  time.Time  `json:"start_date" gorm:"not null"`
        EndDate    *time.Time `json:"end_date"`

        TotalAmount float64 `json:"total_amount" gorm:"type:decimal(15,2);not null"`
        Currency    string  `json:"currency" gorm:"default:'USD'"`

        IsActive bool   `json:"is_active" gorm:"default:true"`
        Settings string `json:"settings" gorm:"type:jsonb;default:'{}'"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// BudgetCategory represents a category allocation within a budget
type BudgetCategory struct {
        ID         uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        BudgetID   uuid.UUID `json:"budget_id" gorm:"type:uuid;not null"`
        CategoryID uuid.UUID `json:"category_id" gorm:"type:uuid;not null"`

        AllocatedAmount float64 `json:"allocated_amount" gorm:"type:decimal(15,2);not null"`
        SpentAmount     float64 `json:"spent_amount" gorm:"type:decimal(15,2);default:0.00"`

        AlertThreshold float64 `json:"alert_threshold" gorm:"type:decimal(3,2);default:0.80"`
        IsActive       bool    `json:"is_active" gorm:"default:true"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// PeriodType represents the budget period type
type PeriodType string

const (
        PeriodTypeMonthly   PeriodType = "monthly"
        PeriodTypeQuarterly PeriodType = "quarterly"
        PeriodTypeYearly    PeriodType = "yearly"
        PeriodTypeCustom    PeriodType = "custom"
)

// CreateBudgetRequest represents a request to create a new budget
type CreateBudgetRequest struct {
        Name        string     `json:"name" binding:"required"`
        Description string     `json:"description"`
        PeriodType  PeriodType `json:"period_type" binding:"required"`
        StartDate   time.Time  `json:"start_date" binding:"required"`
        EndDate     *time.Time `json:"end_date"`
        TotalAmount float64    `json:"total_amount" binding:"required"`
        Currency    string     `json:"currency"`
        Settings    string     `json:"settings"`
}

// UpdateBudgetRequest represents a request to update a budget
type UpdateBudgetRequest struct {
        Name        *string     `json:"name"`
        Description *string     `json:"description"`
        PeriodType  *PeriodType `json:"period_type"`
        StartDate   *time.Time  `json:"start_date"`
        EndDate     *time.Time  `json:"end_date"`
        TotalAmount *float64    `json:"total_amount"`
        Currency    *string     `json:"currency"`
        IsActive    *bool       `json:"is_active"`
        Settings    *string     `json:"settings"`
}

// CreateBudgetCategoryRequest represents a request to create a budget category
type CreateBudgetCategoryRequest struct {
        CategoryID      uuid.UUID `json:"category_id" binding:"required"`
        AllocatedAmount float64   `json:"allocated_amount" binding:"required"`
        AlertThreshold  float64   `json:"alert_threshold"`
}

// UpdateBudgetCategoryRequest represents a request to update a budget category
type UpdateBudgetCategoryRequest struct {
        AllocatedAmount *float64 `json:"allocated_amount"`
        AlertThreshold  *float64 `json:"alert_threshold"`
        IsActive        *bool    `json:"is_active"`
}

// BudgetResponse represents a budget response
type BudgetResponse struct {
        ID          uuid.UUID  `json:"id"`
        UserID      uuid.UUID  `json:"user_id"`
        FamilyID    *uuid.UUID `json:"family_id"`
        Name        string     `json:"name"`
        Description string     `json:"description"`
        PeriodType  PeriodType `json:"period_type"`
        StartDate   time.Time  `json:"start_date"`
        EndDate     *time.Time `json:"end_date"`
        TotalAmount float64    `json:"total_amount"`
        Currency    string     `json:"currency"`
        IsActive    bool       `json:"is_active"`
        Settings    string     `json:"settings"`
        CreatedAt   time.Time  `json:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at"`
}

// BudgetCategoryResponse represents a budget category response
type BudgetCategoryResponse struct {
        ID              uuid.UUID `json:"id"`
        BudgetID        uuid.UUID `json:"budget_id"`
        CategoryID      uuid.UUID `json:"category_id"`
        AllocatedAmount float64   `json:"allocated_amount"`
        SpentAmount     float64   `json:"spent_amount"`
        AlertThreshold  float64   `json:"alert_threshold"`
        IsActive        bool      `json:"is_active"`
        CreatedAt       time.Time `json:"created_at"`
        UpdatedAt       time.Time `json:"updated_at"`
}

// BudgetSummary represents a budget summary with spending analysis
type BudgetSummary struct {
        Budget           *BudgetResponse          `json:"budget"`
        Categories       []BudgetCategoryResponse `json:"categories"`
        TotalAllocated   float64                  `json:"total_allocated"`
        TotalSpent       float64                  `json:"total_spent"`
        RemainingAmount  float64                  `json:"remaining_amount"`
        SpendingProgress float64                  `json:"spending_progress"` // Percentage spent
        Alerts           []BudgetAlert            `json:"alerts"`
}

// BudgetAlert represents a budget alert
type BudgetAlert struct {
        CategoryID      uuid.UUID `json:"category_id"`
        CategoryName    string    `json:"category_name"`
        AllocatedAmount float64   `json:"allocated_amount"`
        SpentAmount     float64   `json:"spent_amount"`
        Threshold       float64   `json:"threshold"`
        AlertType       string    `json:"alert_type"` // "warning", "critical", "over_budget"
        Message         string    `json:"message"`
}

// TableName specifies the table name for Budget
func (Budget) TableName() string <span class="cov0" title="0">{
        return "budgets"
}</span>

// TableName specifies the table name for BudgetCategory
func (BudgetCategory) TableName() string <span class="cov0" title="0">{
        return "budget_categories"
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package budget

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository defines the interface for budget data access
type Repository interface {
        // Budget operations
        Create(ctx context.Context, budget *Budget) error
        GetByID(ctx context.Context, id uuid.UUID) (*Budget, error)
        GetByUserID(ctx context.Context, userID uuid.UUID, offset, limit int) ([]Budget, error)
        Update(ctx context.Context, budget *Budget) error
        Delete(ctx context.Context, id uuid.UUID) error

        // Budget category operations
        CreateCategory(ctx context.Context, budgetCategory *BudgetCategory) error
        GetCategoryByID(ctx context.Context, id uuid.UUID) (*BudgetCategory, error)
        GetCategoriesByBudgetID(ctx context.Context, budgetID uuid.UUID) ([]BudgetCategory, error)
        UpdateCategory(ctx context.Context, budgetCategory *BudgetCategory) error
        DeleteCategory(ctx context.Context, id uuid.UUID) error

        // Budget analysis operations
        GetBudgetSummary(ctx context.Context, budgetID uuid.UUID) (*BudgetSummary, error)
        UpdateSpentAmount(ctx context.Context, budgetID, categoryID uuid.UUID, amount float64) error
        GetActiveBudgetsByUser(ctx context.Context, userID uuid.UUID) ([]Budget, error)
}

// repository implements the Repository interface
type repository struct {
        db *gorm.DB
}

// NewRepository creates a new budget repository
func NewRepository(db *gorm.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Create creates a new budget
func (r *repository) Create(ctx context.Context, budget *Budget) error <span class="cov0" title="0">{
        budget.CreatedAt = time.Now()
        budget.UpdatedAt = time.Now()

        if budget.Currency == "" </span><span class="cov0" title="0">{
                budget.Currency = "USD"
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).Create(budget).Error</span>
}

// GetByID retrieves a budget by ID
func (r *repository) GetByID(ctx context.Context, id uuid.UUID) (*Budget, error) <span class="cov0" title="0">{
        var budget Budget
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;budget).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("budget not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get budget: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;budget, nil</span>
}

// GetByUserID retrieves budgets for a user with pagination
func (r *repository) GetByUserID(ctx context.Context, userID uuid.UUID, offset, limit int) ([]Budget, error) <span class="cov0" title="0">{
        var budgets []Budget
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;budgets).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get budgets: %w", err)
        }</span>

        <span class="cov0" title="0">return budgets, nil</span>
}

// Update updates a budget
func (r *repository) Update(ctx context.Context, budget *Budget) error <span class="cov0" title="0">{
        budget.UpdatedAt = time.Now()

        result := r.db.WithContext(ctx).Save(budget)
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update budget: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("budget not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a budget
func (r *repository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;Budget{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete budget: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("budget not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateCategory creates a new budget category
func (r *repository) CreateCategory(ctx context.Context, budgetCategory *BudgetCategory) error <span class="cov0" title="0">{
        budgetCategory.CreatedAt = time.Now()
        budgetCategory.UpdatedAt = time.Now()

        if budgetCategory.AlertThreshold == 0 </span><span class="cov0" title="0">{
                budgetCategory.AlertThreshold = 0.80 // Default 80% threshold
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).Create(budgetCategory).Error</span>
}

// GetCategoryByID retrieves a budget category by ID
func (r *repository) GetCategoryByID(ctx context.Context, id uuid.UUID) (*BudgetCategory, error) <span class="cov0" title="0">{
        var budgetCategory BudgetCategory
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;budgetCategory).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("budget category not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get budget category: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;budgetCategory, nil</span>
}

// GetCategoriesByBudgetID retrieves all categories for a budget
func (r *repository) GetCategoriesByBudgetID(ctx context.Context, budgetID uuid.UUID) ([]BudgetCategory, error) <span class="cov0" title="0">{
        var budgetCategories []BudgetCategory
        err := r.db.WithContext(ctx).
                Where("budget_id = ?", budgetID).
                Order("created_at ASC").
                Find(&amp;budgetCategories).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get budget categories: %w", err)
        }</span>

        <span class="cov0" title="0">return budgetCategories, nil</span>
}

// UpdateCategory updates a budget category
func (r *repository) UpdateCategory(ctx context.Context, budgetCategory *BudgetCategory) error <span class="cov0" title="0">{
        budgetCategory.UpdatedAt = time.Now()

        result := r.db.WithContext(ctx).Save(budgetCategory)
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update budget category: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("budget category not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteCategory deletes a budget category
func (r *repository) DeleteCategory(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;BudgetCategory{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete budget category: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("budget category not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBudgetSummary retrieves a comprehensive budget summary
func (r *repository) GetBudgetSummary(ctx context.Context, budgetID uuid.UUID) (*BudgetSummary, error) <span class="cov0" title="0">{
        // Get the budget
        budget, err := r.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get budget categories
        <span class="cov0" title="0">categories, err := r.GetCategoriesByBudgetID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate totals
        <span class="cov0" title="0">var totalAllocated, totalSpent float64
        for _, category := range categories </span><span class="cov0" title="0">{
                totalAllocated += category.AllocatedAmount
                totalSpent += category.SpentAmount
        }</span>

        // Calculate spending progress
        <span class="cov0" title="0">var spendingProgress float64
        if totalAllocated &gt; 0 </span><span class="cov0" title="0">{
                spendingProgress = (totalSpent / totalAllocated) * 100
        }</span>

        // Generate alerts
        <span class="cov0" title="0">alerts := r.generateAlerts(categories)

        // Convert to response types
        budgetResponse := &amp;BudgetResponse{
                ID:          budget.ID,
                UserID:      budget.UserID,
                FamilyID:    budget.FamilyID,
                Name:        budget.Name,
                Description: budget.Description,
                PeriodType:  budget.PeriodType,
                StartDate:   budget.StartDate,
                EndDate:     budget.EndDate,
                TotalAmount: budget.TotalAmount,
                Currency:    budget.Currency,
                IsActive:    budget.IsActive,
                Settings:    budget.Settings,
                CreatedAt:   budget.CreatedAt,
                UpdatedAt:   budget.UpdatedAt,
        }

        categoryResponses := make([]BudgetCategoryResponse, len(categories))
        for i, category := range categories </span><span class="cov0" title="0">{
                categoryResponses[i] = BudgetCategoryResponse(category)
        }</span>

        <span class="cov0" title="0">return &amp;BudgetSummary{
                Budget:           budgetResponse,
                Categories:       categoryResponses,
                TotalAllocated:   totalAllocated,
                TotalSpent:       totalSpent,
                RemainingAmount:  totalAllocated - totalSpent,
                SpendingProgress: spendingProgress,
                Alerts:           alerts,
        }, nil</span>
}

// UpdateSpentAmount updates the spent amount for a budget category
func (r *repository) UpdateSpentAmount(ctx context.Context, budgetID, categoryID uuid.UUID, amount float64) error <span class="cov0" title="0">{
        // This would typically be called when a transaction is created/updated
        // For now, we'll just update the spent amount directly
        result := r.db.WithContext(ctx).
                Model(&amp;BudgetCategory{}).
                Where("budget_id = ? AND category_id = ?", budgetID, categoryID).
                Update("spent_amount", amount)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update spent amount: %w", result.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetActiveBudgetsByUser retrieves active budgets for a user
func (r *repository) GetActiveBudgetsByUser(ctx context.Context, userID uuid.UUID) ([]Budget, error) <span class="cov0" title="0">{
        var budgets []Budget
        err := r.db.WithContext(ctx).
                Where("user_id = ? AND is_active = ?", userID, true).
                Order("created_at DESC").
                Find(&amp;budgets).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active budgets: %w", err)
        }</span>

        <span class="cov0" title="0">return budgets, nil</span>
}

// generateAlerts generates budget alerts based on spending thresholds
func (r *repository) generateAlerts(categories []BudgetCategory) []BudgetAlert <span class="cov0" title="0">{
        var alerts []BudgetAlert

        for _, category := range categories </span><span class="cov0" title="0">{
                if category.AllocatedAmount &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">spendingRatio := category.SpentAmount / category.AllocatedAmount

                var alertType string
                var message string

                if spendingRatio &gt;= 1.0 </span><span class="cov0" title="0">{
                        // Over budget
                        alertType = "over_budget"
                        message = fmt.Sprintf("You've exceeded your budget for this category by $%.2f",
                                category.SpentAmount-category.AllocatedAmount)
                }</span> else<span class="cov0" title="0"> if spendingRatio &gt;= category.AlertThreshold </span><span class="cov0" title="0">{
                        // Warning threshold reached
                        alertType = "warning"
                        message = fmt.Sprintf("You've used %.1f%% of your budget for this category",
                                spendingRatio*100)
                }</span> else<span class="cov0" title="0"> if spendingRatio &gt;= 0.9 </span><span class="cov0" title="0">{
                        // Critical threshold (90%)
                        alertType = "critical"
                        message = fmt.Sprintf("You're approaching your budget limit (%.1f%% used)",
                                spendingRatio*100)
                }</span>

                <span class="cov0" title="0">if alertType != "" </span><span class="cov0" title="0">{
                        alerts = append(alerts, BudgetAlert{
                                CategoryID:      category.CategoryID,
                                AllocatedAmount: category.AllocatedAmount,
                                SpentAmount:     category.SpentAmount,
                                Threshold:       category.AlertThreshold,
                                AlertType:       alertType,
                                Message:         message,
                        })
                }</span>
        }

        <span class="cov0" title="0">return alerts</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package budget

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// Service defines the interface for budget business logic
type Service interface {
        // Budget operations
        CreateBudget(ctx context.Context, userID uuid.UUID, req *CreateBudgetRequest) (*BudgetResponse, error)
        GetBudget(ctx context.Context, userID, budgetID uuid.UUID) (*BudgetResponse, error)
        ListBudgets(ctx context.Context, userID uuid.UUID, offset, limit int) ([]BudgetResponse, error)
        UpdateBudget(ctx context.Context, userID, budgetID uuid.UUID, req *UpdateBudgetRequest) (*BudgetResponse, error)
        DeleteBudget(ctx context.Context, userID, budgetID uuid.UUID) error

        // Budget category operations
        AddBudgetCategory(ctx context.Context, userID, budgetID uuid.UUID, req *CreateBudgetCategoryRequest) (*BudgetCategoryResponse, error)
        GetBudgetCategory(ctx context.Context, userID, budgetID, categoryID uuid.UUID) (*BudgetCategoryResponse, error)
        ListBudgetCategories(ctx context.Context, userID, budgetID uuid.UUID) ([]BudgetCategoryResponse, error)
        UpdateBudgetCategory(ctx context.Context, userID, budgetID, categoryID uuid.UUID, req *UpdateBudgetCategoryRequest) (*BudgetCategoryResponse, error)
        DeleteBudgetCategory(ctx context.Context, userID, budgetID, categoryID uuid.UUID) error

        // Budget analysis
        GetBudgetSummary(ctx context.Context, userID, budgetID uuid.UUID) (*BudgetSummary, error)
        UpdateBudgetFromTransaction(ctx context.Context, userID, budgetID, categoryID uuid.UUID, amount float64) error
}

// service implements the Service interface
type service struct {
        repo Repository
}

// NewService creates a new budget service
func NewService(repo Repository) Service <span class="cov10" title="11">{
        return &amp;service{repo: repo}
}</span>

// CreateBudget creates a new budget for a user
func (s *service) CreateBudget(ctx context.Context, userID uuid.UUID, req *CreateBudgetRequest) (*BudgetResponse, error) <span class="cov5" title="3">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.CreateBudget",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_name", req.Name),
                        attribute.String("period_type", string(req.PeriodType)),
                ),
        )
        defer span.End()

        // Validate request
        if err := s.validateCreateBudgetRequest(req); err != nil </span><span class="cov3" title="2">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Create budget
        <span class="cov1" title="1">budget := &amp;Budget{
                UserID:      userID,
                Name:        req.Name,
                Description: req.Description,
                PeriodType:  req.PeriodType,
                StartDate:   req.StartDate,
                EndDate:     req.EndDate,
                TotalAmount: req.TotalAmount,
                Currency:    req.Currency,
                Settings:    req.Settings,
                IsActive:    true,
        }

        if err := s.repo.Create(ctx, budget); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, fmt.Errorf("failed to create budget: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetAttributes(attribute.String("budget_id", budget.ID.String()))
        return s.toBudgetResponse(budget), nil</span>
}

// GetBudget retrieves a budget by ID
func (s *service) GetBudget(ctx context.Context, userID, budgetID uuid.UUID) (*BudgetResponse, error) <span class="cov3" title="2">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.GetBudget",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                ),
        )
        defer span.End()

        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Check ownership
        <span class="cov3" title="2">if budget.UserID != userID </span><span class="cov1" title="1">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov1" title="1">return s.toBudgetResponse(budget), nil</span>
}

// ListBudgets retrieves budgets for a user
func (s *service) ListBudgets(ctx context.Context, userID uuid.UUID, offset, limit int) ([]BudgetResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.ListBudgets",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.Int("offset", offset),
                        attribute.Int("limit", limit),
                ),
        )
        defer span.End()

        budgets, err := s.repo.GetByUserID(ctx, userID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">responses := make([]BudgetResponse, len(budgets))
        for i, budget := range budgets </span><span class="cov3" title="2">{
                responses[i] = *s.toBudgetResponse(&amp;budget)
        }</span>

        <span class="cov1" title="1">span.SetAttributes(attribute.Int("budgets_count", len(responses)))
        return responses, nil</span>
}

// UpdateBudget updates a budget
func (s *service) UpdateBudget(ctx context.Context, userID, budgetID uuid.UUID, req *UpdateBudgetRequest) (*BudgetResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.UpdateBudget",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                ),
        )
        defer span.End()

        // Get existing budget
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Check ownership
        <span class="cov1" title="1">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        // Update fields
        <span class="cov1" title="1">if req.Name != nil </span><span class="cov1" title="1">{
                budget.Name = *req.Name
        }</span>
        <span class="cov1" title="1">if req.Description != nil </span><span class="cov1" title="1">{
                budget.Description = *req.Description
        }</span>
        <span class="cov1" title="1">if req.PeriodType != nil </span><span class="cov0" title="0">{
                budget.PeriodType = *req.PeriodType
        }</span>
        <span class="cov1" title="1">if req.StartDate != nil </span><span class="cov0" title="0">{
                budget.StartDate = *req.StartDate
        }</span>
        <span class="cov1" title="1">if req.EndDate != nil </span><span class="cov0" title="0">{
                budget.EndDate = req.EndDate
        }</span>
        <span class="cov1" title="1">if req.TotalAmount != nil </span><span class="cov0" title="0">{
                budget.TotalAmount = *req.TotalAmount
        }</span>
        <span class="cov1" title="1">if req.Currency != nil </span><span class="cov0" title="0">{
                budget.Currency = *req.Currency
        }</span>
        <span class="cov1" title="1">if req.IsActive != nil </span><span class="cov0" title="0">{
                budget.IsActive = *req.IsActive
        }</span>
        <span class="cov1" title="1">if req.Settings != nil </span><span class="cov0" title="0">{
                budget.Settings = *req.Settings
        }</span>

        // Validate updated budget
        <span class="cov1" title="1">if err := s.validateBudget(budget); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := s.repo.Update(ctx, budget); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">return s.toBudgetResponse(budget), nil</span>
}

// DeleteBudget deletes a budget
func (s *service) DeleteBudget(ctx context.Context, userID, budgetID uuid.UUID) error <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.DeleteBudget",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                ),
        )
        defer span.End()

        // Get existing budget to check ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        // Check ownership
        <span class="cov1" title="1">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov1" title="1">if err := s.repo.Delete(ctx, budgetID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// AddBudgetCategory adds a category to a budget
func (s *service) AddBudgetCategory(ctx context.Context, userID, budgetID uuid.UUID, req *CreateBudgetCategoryRequest) (*BudgetCategoryResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.AddBudgetCategory",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                        attribute.String("category_id", req.CategoryID.String()),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        // Create budget category
        <span class="cov1" title="1">budgetCategory := &amp;BudgetCategory{
                BudgetID:        budgetID,
                CategoryID:      req.CategoryID,
                AllocatedAmount: req.AllocatedAmount,
                AlertThreshold:  req.AlertThreshold,
                IsActive:        true,
        }

        if err := s.repo.CreateCategory(ctx, budgetCategory); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">span.SetAttributes(attribute.String("budget_category_id", budgetCategory.ID.String()))
        return s.toBudgetCategoryResponse(budgetCategory), nil</span>
}

// GetBudgetCategory retrieves a budget category
func (s *service) GetBudgetCategory(ctx context.Context, userID, budgetID, categoryID uuid.UUID) (*BudgetCategoryResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.GetBudgetCategory",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov0" title="0">budgetCategory, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Verify the category belongs to the budget
        <span class="cov0" title="0">if budgetCategory.BudgetID != budgetID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "category does not belong to budget")
                return nil, fmt.Errorf("category does not belong to budget")
        }</span>

        <span class="cov0" title="0">return s.toBudgetCategoryResponse(budgetCategory), nil</span>
}

// ListBudgetCategories retrieves all categories for a budget
func (s *service) ListBudgetCategories(ctx context.Context, userID, budgetID uuid.UUID) ([]BudgetCategoryResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.ListBudgetCategories",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov0" title="0">categories, err := s.repo.GetCategoriesByBudgetID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">responses := make([]BudgetCategoryResponse, len(categories))
        for i, category := range categories </span><span class="cov0" title="0">{
                responses[i] = *s.toBudgetCategoryResponse(&amp;category)
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.Int("categories_count", len(responses)))
        return responses, nil</span>
}

// UpdateBudgetCategory updates a budget category
func (s *service) UpdateBudgetCategory(ctx context.Context, userID, budgetID, categoryID uuid.UUID, req *UpdateBudgetCategoryRequest) (*BudgetCategoryResponse, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.UpdateBudgetCategory",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov0" title="0">budgetCategory, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        // Verify the category belongs to the budget
        <span class="cov0" title="0">if budgetCategory.BudgetID != budgetID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "category does not belong to budget")
                return nil, fmt.Errorf("category does not belong to budget")
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.AllocatedAmount != nil </span><span class="cov0" title="0">{
                budgetCategory.AllocatedAmount = *req.AllocatedAmount
        }</span>
        <span class="cov0" title="0">if req.AlertThreshold != nil </span><span class="cov0" title="0">{
                budgetCategory.AlertThreshold = *req.AlertThreshold
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                budgetCategory.IsActive = *req.IsActive
        }</span>

        <span class="cov0" title="0">if err := s.repo.UpdateCategory(ctx, budgetCategory); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toBudgetCategoryResponse(budgetCategory), nil</span>
}

// DeleteBudgetCategory deletes a budget category
func (s *service) DeleteBudgetCategory(ctx context.Context, userID, budgetID, categoryID uuid.UUID) error <span class="cov0" title="0">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.DeleteBudgetCategory",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov0" title="0">budgetCategory, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        // Verify the category belongs to the budget
        <span class="cov0" title="0">if budgetCategory.BudgetID != budgetID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "category does not belong to budget")
                return fmt.Errorf("category does not belong to budget")
        }</span>

        <span class="cov0" title="0">if err := s.repo.DeleteCategory(ctx, categoryID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBudgetSummary retrieves a comprehensive budget summary
func (s *service) GetBudgetSummary(ctx context.Context, userID, budgetID uuid.UUID) (*BudgetSummary, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.GetBudgetSummary",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return nil, fmt.Errorf("unauthorized access to budget")
        }</span>

        <span class="cov1" title="1">summary, err := s.repo.GetBudgetSummary(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Float64("total_allocated", summary.TotalAllocated),
                attribute.Float64("total_spent", summary.TotalSpent),
                attribute.Float64("spending_progress", summary.SpendingProgress),
                attribute.Int("alerts_count", len(summary.Alerts)),
        )

        return summary, nil</span>
}

// UpdateBudgetFromTransaction updates budget spending when a transaction is created/updated
func (s *service) UpdateBudgetFromTransaction(ctx context.Context, userID, budgetID, categoryID uuid.UUID, amount float64) error <span class="cov1" title="1">{
        ctx, span := otel.Tracer("").Start(ctx, "budget.UpdateBudgetFromTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("budget_id", budgetID.String()),
                        attribute.String("category_id", categoryID.String()),
                        attribute.Float64("amount", amount),
                ),
        )
        defer span.End()

        // Verify budget ownership
        budget, err := s.repo.GetByID(ctx, budgetID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov1" title="1">if budget.UserID != userID </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, "unauthorized access to budget")
                return fmt.Errorf("unauthorized access to budget")
        }</span>

        // Update the spent amount for the category
        <span class="cov1" title="1">if err := s.repo.UpdateSpentAmount(ctx, budgetID, categoryID, amount); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Helper methods

func (s *service) validateCreateBudgetRequest(req *CreateBudgetRequest) error <span class="cov5" title="3">{
        if req.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("budget name is required")
        }</span>
        <span class="cov3" title="2">if req.TotalAmount &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("total amount must be positive")
        }</span>
        <span class="cov1" title="1">if req.StartDate.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("start date is required")
        }</span>
        <span class="cov1" title="1">if req.EndDate != nil &amp;&amp; req.EndDate.Before(req.StartDate) </span><span class="cov0" title="0">{
                return fmt.Errorf("end date must be after start date")
        }</span>
        <span class="cov1" title="1">if req.Currency == "" </span><span class="cov0" title="0">{
                req.Currency = "USD"
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (s *service) validateBudget(budget *Budget) error <span class="cov1" title="1">{
        if budget.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("budget name is required")
        }</span>
        <span class="cov1" title="1">if budget.TotalAmount &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("total amount must be positive")
        }</span>
        <span class="cov1" title="1">if budget.StartDate.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("start date is required")
        }</span>
        <span class="cov1" title="1">if budget.EndDate != nil &amp;&amp; budget.EndDate.Before(budget.StartDate) </span><span class="cov0" title="0">{
                return fmt.Errorf("end date must be after start date")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (s *service) toBudgetResponse(budget *Budget) *BudgetResponse <span class="cov7" title="5">{
        return &amp;BudgetResponse{
                ID:          budget.ID,
                UserID:      budget.UserID,
                FamilyID:    budget.FamilyID,
                Name:        budget.Name,
                Description: budget.Description,
                PeriodType:  budget.PeriodType,
                StartDate:   budget.StartDate,
                EndDate:     budget.EndDate,
                TotalAmount: budget.TotalAmount,
                Currency:    budget.Currency,
                IsActive:    budget.IsActive,
                Settings:    budget.Settings,
                CreatedAt:   budget.CreatedAt,
                UpdatedAt:   budget.UpdatedAt,
        }
}</span>

func (s *service) toBudgetCategoryResponse(budgetCategory *BudgetCategory) *BudgetCategoryResponse <span class="cov1" title="1">{
        return &amp;BudgetCategoryResponse{
                ID:              budgetCategory.ID,
                BudgetID:        budgetCategory.BudgetID,
                CategoryID:      budgetCategory.CategoryID,
                AllocatedAmount: budgetCategory.AllocatedAmount,
                SpentAmount:     budgetCategory.SpentAmount,
                AlertThreshold:  budgetCategory.AlertThreshold,
                IsActive:        budgetCategory.IsActive,
                CreatedAt:       budgetCategory.CreatedAt,
                UpdatedAt:       budgetCategory.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package transaction

import (
        "time"

        "github.com/google/uuid"
)

// Transaction represents a financial transaction
type Transaction struct {
        ID         uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID     uuid.UUID  `json:"user_id" gorm:"type:uuid;not null"`
        FamilyID   *uuid.UUID `json:"family_id" gorm:"type:uuid"`
        AccountID  uuid.UUID  `json:"account_id" gorm:"type:uuid;not null"`
        CategoryID *uuid.UUID `json:"category_id" gorm:"type:uuid"`

        Amount      float64 `json:"amount" gorm:"type:decimal(15,2);not null"`
        Currency    string  `json:"currency" gorm:"default:'USD'"`
        Description string  `json:"description" gorm:"not null"`
        Merchant    string  `json:"merchant"`
        Location    string  `json:"location" gorm:"type:jsonb"`

        TransactionDate time.Time         `json:"transaction_date" gorm:"not null"`
        PostedDate      *time.Time        `json:"posted_date"`
        Status          TransactionStatus `json:"status" gorm:"default:'pending'"`

        CategorizationSource     CategorizationSource `json:"categorization_source" gorm:"default:'manual'"`
        CategorizationConfidence *float64             `json:"categorization_confidence"`

        Tags       []string `json:"tags" gorm:"type:text[]"`
        Notes      string   `json:"notes"`
        ReceiptURL string   `json:"receipt_url"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// TransactionStatus represents the status of a transaction
type TransactionStatus string

const (
        TransactionStatusPending   TransactionStatus = "pending"
        TransactionStatusPosted    TransactionStatus = "posted"
        TransactionStatusCancelled TransactionStatus = "cancelled"
        TransactionStatusDisputed  TransactionStatus = "disputed"
)

// CategorizationSource represents how the transaction was categorized
type CategorizationSource string

const (
        CategorizationSourceManual         CategorizationSource = "manual"
        CategorizationSourceML             CategorizationSource = "ml"
        CategorizationSourcePlaid          CategorizationSource = "plaid"
        CategorizationSourceUserCorrection CategorizationSource = "user_correction"
)

// Category represents a transaction category
type Category struct {
        ID          uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Name        string     `json:"name" gorm:"not null"`
        Description string     `json:"description"`
        Icon        string     `json:"icon"`
        Color       string     `json:"color"`
        ParentID    *uuid.UUID `json:"parent_id" gorm:"type:uuid"`
        IsDefault   bool       `json:"is_default" gorm:"default:false"`
        IsActive    bool       `json:"is_active" gorm:"default:true"`
        SortOrder   int        `json:"sort_order" gorm:"default:0"`
        CreatedAt   time.Time  `json:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at"`
}

// Account represents a financial account
type Account struct {
        ID                uuid.UUID   `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID            uuid.UUID   `json:"user_id" gorm:"type:uuid;not null"`
        FamilyID          *uuid.UUID  `json:"family_id" gorm:"type:uuid"`
        Name              string      `json:"name" gorm:"not null"`
        Type              AccountType `json:"type" gorm:"not null"`
        Institution       string      `json:"institution"`
        AccountNumberHash string      `json:"account_number_hash"`
        Balance           float64     `json:"balance" gorm:"type:decimal(15,2);default:0.00"`
        Currency          string      `json:"currency" gorm:"default:'USD'"`
        IsActive          bool        `json:"is_active" gorm:"default:true"`
        PlaidAccountID    string      `json:"plaid_account_id"`
        LastSyncAt        *time.Time  `json:"last_sync_at"`
        Settings          string      `json:"settings" gorm:"type:jsonb;default:'{}'"`
        CreatedAt         time.Time   `json:"created_at"`
        UpdatedAt         time.Time   `json:"updated_at"`
}

// AccountType represents the type of account
type AccountType string

const (
        AccountTypeChecking   AccountType = "checking"
        AccountTypeSavings    AccountType = "savings"
        AccountTypeCreditCard AccountType = "credit_card"
        AccountTypeInvestment AccountType = "investment"
        AccountTypeLoan       AccountType = "loan"
        AccountTypeOther      AccountType = "other"
)

// CreateTransactionRequest represents a request to create a new transaction
type CreateTransactionRequest struct {
        AccountID       uuid.UUID  `json:"account_id" binding:"required"`
        CategoryID      *uuid.UUID `json:"category_id"`
        Amount          float64    `json:"amount" binding:"required"`
        Currency        string     `json:"currency"`
        Description     string     `json:"description" binding:"required"`
        Merchant        string     `json:"merchant"`
        Location        string     `json:"location"`
        TransactionDate time.Time  `json:"transaction_date" binding:"required"`
        PostedDate      *time.Time `json:"posted_date"`
        Tags            []string   `json:"tags"`
        Notes           string     `json:"notes"`
}

// UpdateTransactionRequest represents a request to update a transaction
type UpdateTransactionRequest struct {
        CategoryID      *uuid.UUID         `json:"category_id"`
        Amount          *float64           `json:"amount"`
        Currency        string             `json:"currency"`
        Description     string             `json:"description"`
        Merchant        string             `json:"merchant"`
        Location        string             `json:"location"`
        TransactionDate *time.Time         `json:"transaction_date"`
        PostedDate      *time.Time         `json:"posted_date"`
        Status          *TransactionStatus `json:"status"`
        Tags            []string           `json:"tags"`
        Notes           string             `json:"notes"`
}

// TransactionResponse represents a transaction response
type TransactionResponse struct {
        ID                       uuid.UUID            `json:"id"`
        UserID                   uuid.UUID            `json:"user_id"`
        FamilyID                 *uuid.UUID           `json:"family_id"`
        AccountID                uuid.UUID            `json:"account_id"`
        CategoryID               *uuid.UUID           `json:"category_id"`
        Amount                   float64              `json:"amount"`
        Currency                 string               `json:"currency"`
        Description              string               `json:"description"`
        Merchant                 string               `json:"merchant"`
        Location                 string               `json:"location"`
        TransactionDate          time.Time            `json:"transaction_date"`
        PostedDate               *time.Time           `json:"posted_date"`
        Status                   TransactionStatus    `json:"status"`
        CategorizationSource     CategorizationSource `json:"categorization_source"`
        CategorizationConfidence *float64             `json:"categorization_confidence"`
        Tags                     []string             `json:"tags"`
        Notes                    string               `json:"notes"`
        ReceiptURL               string               `json:"receipt_url"`
        CreatedAt                time.Time            `json:"created_at"`
        UpdatedAt                time.Time            `json:"updated_at"`
}

// CreateCategoryRequest represents a request to create a new category
type CreateCategoryRequest struct {
        Name        string     `json:"name" binding:"required"`
        Description string     `json:"description"`
        Icon        string     `json:"icon"`
        Color       string     `json:"color"`
        ParentID    *uuid.UUID `json:"parent_id"`
        IsDefault   bool       `json:"is_default"`
        SortOrder   int        `json:"sort_order"`
}

// CreateAccountRequest represents a request to create a new account
type CreateAccountRequest struct {
        Name              string      `json:"name" binding:"required"`
        Type              AccountType `json:"type" binding:"required"`
        Institution       string      `json:"institution"`
        AccountNumberHash string      `json:"account_number_hash"`
        Balance           float64     `json:"balance"`
        Currency          string      `json:"currency"`
        PlaidAccountID    string      `json:"plaid_account_id"`
}

// TableName specifies the table name for Transaction
func (Transaction) TableName() string <span class="cov0" title="0">{
        return "transactions"
}</span>

// TableName specifies the table name for Category
func (Category) TableName() string <span class="cov0" title="0">{
        return "categories"
}</span>

// TableName specifies the table name for Account
func (Account) TableName() string <span class="cov0" title="0">{
        return "accounts"
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package transaction

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository defines the interface for transaction data operations
type Repository interface {
        // Transaction operations
        CreateTransaction(ctx context.Context, transaction *Transaction) error
        GetTransactionByID(ctx context.Context, id uuid.UUID) (*Transaction, error)
        GetTransactionsByUser(ctx context.Context, userID uuid.UUID, offset, limit int) ([]Transaction, error)
        GetTransactionsByAccount(ctx context.Context, accountID uuid.UUID, offset, limit int) ([]Transaction, error)
        UpdateTransaction(ctx context.Context, transaction *Transaction) error
        DeleteTransaction(ctx context.Context, id uuid.UUID) error

        // Category operations
        CreateCategory(ctx context.Context, category *Category) error
        GetCategoryByID(ctx context.Context, id uuid.UUID) (*Category, error)
        GetCategories(ctx context.Context, offset, limit int) ([]Category, error)
        GetDefaultCategories(ctx context.Context) ([]Category, error)
        UpdateCategory(ctx context.Context, category *Category) error
        DeleteCategory(ctx context.Context, id uuid.UUID) error

        // Account operations
        CreateAccount(ctx context.Context, account *Account) error
        GetAccountByID(ctx context.Context, id uuid.UUID) (*Account, error)
        GetAccountsByUser(ctx context.Context, userID uuid.UUID) ([]Account, error)
        UpdateAccount(ctx context.Context, account *Account) error
        DeleteAccount(ctx context.Context, id uuid.UUID) error
}

// repository implements the Repository interface
type repository struct {
        db *gorm.DB
}

// NewRepository creates a new transaction repository
func NewRepository(db *gorm.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Transaction operations

// CreateTransaction creates a new transaction
func (r *repository) CreateTransaction(ctx context.Context, transaction *Transaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(transaction).Error
}</span>

// GetTransactionByID retrieves a transaction by ID
func (r *repository) GetTransactionByID(ctx context.Context, id uuid.UUID) (*Transaction, error) <span class="cov0" title="0">{
        var transaction Transaction
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;transaction).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrTransactionNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;transaction, nil</span>
}

// GetTransactionsByUser retrieves transactions for a user with pagination
func (r *repository) GetTransactionsByUser(ctx context.Context, userID uuid.UUID, offset, limit int) ([]Transaction, error) <span class="cov0" title="0">{
        var transactions []Transaction
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("transaction_date DESC, created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;transactions).Error
        return transactions, err
}</span>

// GetTransactionsByAccount retrieves transactions for an account with pagination
func (r *repository) GetTransactionsByAccount(ctx context.Context, accountID uuid.UUID, offset, limit int) ([]Transaction, error) <span class="cov0" title="0">{
        var transactions []Transaction
        err := r.db.WithContext(ctx).
                Where("account_id = ?", accountID).
                Order("transaction_date DESC, created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;transactions).Error
        return transactions, err
}</span>

// UpdateTransaction updates a transaction
func (r *repository) UpdateTransaction(ctx context.Context, transaction *Transaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(transaction).Error
}</span>

// DeleteTransaction deletes a transaction
func (r *repository) DeleteTransaction(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;Transaction{}, id).Error
}</span>

// Category operations

// CreateCategory creates a new category
func (r *repository) CreateCategory(ctx context.Context, category *Category) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(category).Error
}</span>

// GetCategoryByID retrieves a category by ID
func (r *repository) GetCategoryByID(ctx context.Context, id uuid.UUID) (*Category, error) <span class="cov0" title="0">{
        var category Category
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;category).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrCategoryNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;category, nil</span>
}

// GetCategories retrieves all categories with pagination
func (r *repository) GetCategories(ctx context.Context, offset, limit int) ([]Category, error) <span class="cov0" title="0">{
        var categories []Category
        err := r.db.WithContext(ctx).
                Order("sort_order ASC, name ASC").
                Offset(offset).
                Limit(limit).
                Find(&amp;categories).Error
        return categories, err
}</span>

// GetDefaultCategories retrieves default categories
func (r *repository) GetDefaultCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        var categories []Category
        err := r.db.WithContext(ctx).
                Where("is_default = ?", true).
                Order("sort_order ASC, name ASC").
                Find(&amp;categories).Error
        return categories, err
}</span>

// UpdateCategory updates a category
func (r *repository) UpdateCategory(ctx context.Context, category *Category) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(category).Error
}</span>

// DeleteCategory deletes a category
func (r *repository) DeleteCategory(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;Category{}, id).Error
}</span>

// Account operations

// CreateAccount creates a new account
func (r *repository) CreateAccount(ctx context.Context, account *Account) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(account).Error
}</span>

// GetAccountByID retrieves an account by ID
func (r *repository) GetAccountByID(ctx context.Context, id uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        var account Account
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;account).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrAccountNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;account, nil</span>
}

// GetAccountsByUser retrieves all accounts for a user
func (r *repository) GetAccountsByUser(ctx context.Context, userID uuid.UUID) ([]Account, error) <span class="cov0" title="0">{
        var accounts []Account
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("name ASC").
                Find(&amp;accounts).Error
        return accounts, err
}</span>

// UpdateAccount updates an account
func (r *repository) UpdateAccount(ctx context.Context, account *Account) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(account).Error
}</span>

// DeleteAccount deletes an account
func (r *repository) DeleteAccount(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;Account{}, id).Error
}</span>

// Custom errors
var (
        ErrTransactionNotFound = errors.New("transaction not found")
        ErrCategoryNotFound    = errors.New("category not found")
        ErrAccountNotFound     = errors.New("account not found")
)
</pre>
		
		<pre class="file" id="file22" style="display: none">package transaction

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// Service defines the interface for transaction business logic
type Service interface {
        // Transaction operations
        CreateTransaction(ctx context.Context, userID uuid.UUID, req *CreateTransactionRequest) (*TransactionResponse, error)
        GetTransaction(ctx context.Context, userID, transactionID uuid.UUID) (*TransactionResponse, error)
        GetTransactions(ctx context.Context, userID uuid.UUID, offset, limit int) ([]TransactionResponse, error)
        UpdateTransaction(ctx context.Context, userID, transactionID uuid.UUID, req *UpdateTransactionRequest) (*TransactionResponse, error)
        DeleteTransaction(ctx context.Context, userID, transactionID uuid.UUID) error

        // Category operations
        CreateCategory(ctx context.Context, req *CreateCategoryRequest) (*Category, error)
        GetCategory(ctx context.Context, categoryID uuid.UUID) (*Category, error)
        GetCategories(ctx context.Context, offset, limit int) ([]Category, error)
        GetDefaultCategories(ctx context.Context) ([]Category, error)
        UpdateCategory(ctx context.Context, categoryID uuid.UUID, req *CreateCategoryRequest) (*Category, error)
        DeleteCategory(ctx context.Context, categoryID uuid.UUID) error

        // Account operations
        CreateAccount(ctx context.Context, userID uuid.UUID, req *CreateAccountRequest) (*Account, error)
        GetAccount(ctx context.Context, userID, accountID uuid.UUID) (*Account, error)
        GetAccounts(ctx context.Context, userID uuid.UUID) ([]Account, error)
        UpdateAccount(ctx context.Context, userID, accountID uuid.UUID, req *CreateAccountRequest) (*Account, error)
        DeleteAccount(ctx context.Context, userID, accountID uuid.UUID) error
}

// service implements the Service interface
type service struct {
        repo Repository
}

// NewService creates a new transaction service
func NewService(repo Repository) Service <span class="cov5" title="2">{
        return &amp;service{repo: repo}
}</span>

// Transaction operations

// CreateTransaction creates a new transaction
func (s *service) CreateTransaction(ctx context.Context, userID uuid.UUID, req *CreateTransactionRequest) (*TransactionResponse, error) <span class="cov5" title="2">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "CreateTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", req.AccountID.String()),
                        attribute.Float64("amount", req.Amount),
                ),
        )
        defer span.End()

        // Validate amount
        if req.Amount == 0 </span><span class="cov0" title="0">{
                span.RecordError(errors.New("amount cannot be zero"))
                span.SetStatus(codes.Error, "amount cannot be zero")
                return nil, errors.New("amount cannot be zero")
        }</span>

        // Validate account exists and belongs to user
        <span class="cov5" title="2">account, err := s.repo.GetAccountByID(ctx, req.AccountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return nil, fmt.Errorf("failed to get account: %w", err)
        }</span>

        <span class="cov5" title="2">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return nil, errors.New("account does not belong to user")
        }</span>

        // Validate category if provided
        <span class="cov5" title="2">if req.CategoryID != nil </span><span class="cov0" title="0">{
                _, err := s.repo.GetCategoryByID(ctx, *req.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to get category")
                        return nil, fmt.Errorf("failed to get category: %w", err)
                }</span>
        }

        // Set default currency if not provided
        <span class="cov5" title="2">if req.Currency == "" </span><span class="cov0" title="0">{
                req.Currency = "USD"
        }</span>

        // Create transaction
        <span class="cov5" title="2">transaction := &amp;Transaction{
                UserID:          userID,
                AccountID:       req.AccountID,
                CategoryID:      req.CategoryID,
                Amount:          req.Amount,
                Currency:        req.Currency,
                Description:     req.Description,
                Merchant:        req.Merchant,
                Location:        req.Location,
                TransactionDate: req.TransactionDate,
                PostedDate:      req.PostedDate,
                Status:          TransactionStatusPending,
                Tags:            req.Tags,
                Notes:           req.Notes,
        }

        if err := s.repo.CreateTransaction(ctx, transaction); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create transaction")
                return nil, fmt.Errorf("failed to create transaction: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction created successfully")
        return s.toTransactionResponse(transaction), nil</span>
}

// GetTransaction retrieves a transaction by ID
func (s *service) GetTransaction(ctx context.Context, userID, transactionID uuid.UUID) (*TransactionResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("transaction_id", transactionID.String()),
                ),
        )
        defer span.End()

        transaction, err := s.repo.GetTransactionByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transaction")
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>

        // Check if transaction belongs to user
        <span class="cov1" title="1">if transaction.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("transaction does not belong to user"))
                span.SetStatus(codes.Error, "transaction does not belong to user")
                return nil, errors.New("transaction does not belong to user")
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction retrieved successfully")
        return s.toTransactionResponse(transaction), nil</span>
}

// GetTransactions retrieves transactions for a user with pagination
func (s *service) GetTransactions(ctx context.Context, userID uuid.UUID, offset, limit int) ([]TransactionResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetTransactions",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.Int("offset", offset),
                        attribute.Int("limit", limit),
                ),
        )
        defer span.End()

        // Set default limit if not provided
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov1" title="1">transactions, err := s.repo.GetTransactionsByUser(ctx, userID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transactions")
                return nil, fmt.Errorf("failed to get transactions: %w", err)
        }</span>

        <span class="cov1" title="1">responses := make([]TransactionResponse, len(transactions))
        for i, transaction := range transactions </span><span class="cov1" title="1">{
                responses[i] = *s.toTransactionResponse(&amp;transaction)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transactions retrieved successfully")
        return responses, nil</span>
}

// UpdateTransaction updates a transaction
func (s *service) UpdateTransaction(ctx context.Context, userID, transactionID uuid.UUID, req *UpdateTransactionRequest) (*TransactionResponse, error) <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "UpdateTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("transaction_id", transactionID.String()),
                ),
        )
        defer span.End()

        transaction, err := s.repo.GetTransactionByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transaction")
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>

        // Check if transaction belongs to user
        <span class="cov1" title="1">if transaction.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("transaction does not belong to user"))
                span.SetStatus(codes.Error, "transaction does not belong to user")
                return nil, errors.New("transaction does not belong to user")
        }</span>

        // Update fields if provided
        <span class="cov1" title="1">if req.CategoryID != nil </span><span class="cov0" title="0">{
                // Validate category exists
                _, err := s.repo.GetCategoryByID(ctx, *req.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, "failed to get category")
                        return nil, fmt.Errorf("failed to get category: %w", err)
                }</span>
                <span class="cov0" title="0">transaction.CategoryID = req.CategoryID</span>
        }

        <span class="cov1" title="1">if req.Amount != nil </span><span class="cov0" title="0">{
                if *req.Amount == 0 </span><span class="cov0" title="0">{
                        span.RecordError(errors.New("amount cannot be zero"))
                        span.SetStatus(codes.Error, "amount cannot be zero")
                        return nil, errors.New("amount cannot be zero")
                }</span>
                <span class="cov0" title="0">transaction.Amount = *req.Amount</span>
        }

        <span class="cov1" title="1">if req.Currency != "" </span><span class="cov0" title="0">{
                transaction.Currency = req.Currency
        }</span>

        <span class="cov1" title="1">if req.Description != "" </span><span class="cov1" title="1">{
                transaction.Description = req.Description
        }</span>

        <span class="cov1" title="1">if req.Merchant != "" </span><span class="cov0" title="0">{
                transaction.Merchant = req.Merchant
        }</span>

        <span class="cov1" title="1">if req.Location != "" </span><span class="cov0" title="0">{
                transaction.Location = req.Location
        }</span>

        <span class="cov1" title="1">if req.TransactionDate != nil </span><span class="cov0" title="0">{
                transaction.TransactionDate = *req.TransactionDate
        }</span>

        <span class="cov1" title="1">if req.PostedDate != nil </span><span class="cov0" title="0">{
                transaction.PostedDate = req.PostedDate
        }</span>

        <span class="cov1" title="1">if req.Status != nil </span><span class="cov0" title="0">{
                transaction.Status = *req.Status
        }</span>

        <span class="cov1" title="1">if req.Tags != nil </span><span class="cov0" title="0">{
                transaction.Tags = req.Tags
        }</span>

        <span class="cov1" title="1">if req.Notes != "" </span><span class="cov0" title="0">{
                transaction.Notes = req.Notes
        }</span>

        <span class="cov1" title="1">transaction.UpdatedAt = time.Now()

        if err := s.repo.UpdateTransaction(ctx, transaction); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to update transaction")
                return nil, fmt.Errorf("failed to update transaction: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction updated successfully")
        return s.toTransactionResponse(transaction), nil</span>
}

// DeleteTransaction deletes a transaction
func (s *service) DeleteTransaction(ctx context.Context, userID, transactionID uuid.UUID) error <span class="cov1" title="1">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "DeleteTransaction",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("transaction_id", transactionID.String()),
                ),
        )
        defer span.End()

        transaction, err := s.repo.GetTransactionByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get transaction")
                return fmt.Errorf("failed to get transaction: %w", err)
        }</span>

        // Check if transaction belongs to user
        <span class="cov1" title="1">if transaction.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("transaction does not belong to user"))
                span.SetStatus(codes.Error, "transaction does not belong to user")
                return errors.New("transaction does not belong to user")
        }</span>

        <span class="cov1" title="1">if err := s.repo.DeleteTransaction(ctx, transactionID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to delete transaction")
                return fmt.Errorf("failed to delete transaction: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "transaction deleted successfully")
        return nil</span>
}

// Category operations

// CreateCategory creates a new category
func (s *service) CreateCategory(ctx context.Context, req *CreateCategoryRequest) (*Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "CreateCategory",
                trace.WithAttributes(
                        attribute.String("name", req.Name),
                ),
        )
        defer span.End()

        category := &amp;Category{
                Name:        req.Name,
                Description: req.Description,
                Icon:        req.Icon,
                Color:       req.Color,
                ParentID:    req.ParentID,
                IsDefault:   req.IsDefault,
                SortOrder:   req.SortOrder,
        }

        if err := s.repo.CreateCategory(ctx, category); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create category")
                return nil, fmt.Errorf("failed to create category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category created successfully")
        return category, nil</span>
}

// GetCategory retrieves a category by ID
func (s *service) GetCategory(ctx context.Context, categoryID uuid.UUID) (*Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetCategory",
                trace.WithAttributes(
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        category, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get category")
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category retrieved successfully")
        return category, nil</span>
}

// GetCategories retrieves all categories with pagination
func (s *service) GetCategories(ctx context.Context, offset, limit int) ([]Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetCategories",
                trace.WithAttributes(
                        attribute.Int("offset", offset),
                        attribute.Int("limit", limit),
                ),
        )
        defer span.End()

        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">categories, err := s.repo.GetCategories(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get categories")
                return nil, fmt.Errorf("failed to get categories: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "categories retrieved successfully")
        return categories, nil</span>
}

// GetDefaultCategories retrieves default categories
func (s *service) GetDefaultCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetDefaultCategories")
        defer span.End()

        categories, err := s.repo.GetDefaultCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get default categories")
                return nil, fmt.Errorf("failed to get default categories: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "default categories retrieved successfully")
        return categories, nil</span>
}

// UpdateCategory updates a category
func (s *service) UpdateCategory(ctx context.Context, categoryID uuid.UUID, req *CreateCategoryRequest) (*Category, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "UpdateCategory",
                trace.WithAttributes(
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        category, err := s.repo.GetCategoryByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get category")
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>

        // Update fields
        <span class="cov0" title="0">category.Name = req.Name
        category.Description = req.Description
        category.Icon = req.Icon
        category.Color = req.Color
        category.ParentID = req.ParentID
        category.IsDefault = req.IsDefault
        category.SortOrder = req.SortOrder
        category.UpdatedAt = time.Now()

        if err := s.repo.UpdateCategory(ctx, category); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to update category")
                return nil, fmt.Errorf("failed to update category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category updated successfully")
        return category, nil</span>
}

// DeleteCategory deletes a category
func (s *service) DeleteCategory(ctx context.Context, categoryID uuid.UUID) error <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "DeleteCategory",
                trace.WithAttributes(
                        attribute.String("category_id", categoryID.String()),
                ),
        )
        defer span.End()

        if err := s.repo.DeleteCategory(ctx, categoryID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to delete category")
                return fmt.Errorf("failed to delete category: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "category deleted successfully")
        return nil</span>
}

// Account operations

// CreateAccount creates a new account
func (s *service) CreateAccount(ctx context.Context, userID uuid.UUID, req *CreateAccountRequest) (*Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "CreateAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("name", req.Name),
                        attribute.String("type", string(req.Type)),
                ),
        )
        defer span.End()

        // Set default currency if not provided
        if req.Currency == "" </span><span class="cov0" title="0">{
                req.Currency = "USD"
        }</span>

        <span class="cov0" title="0">account := &amp;Account{
                UserID:            userID,
                Name:              req.Name,
                Type:              req.Type,
                Institution:       req.Institution,
                AccountNumberHash: req.AccountNumberHash,
                Balance:           req.Balance,
                Currency:          req.Currency,
                PlaidAccountID:    req.PlaidAccountID,
        }

        if err := s.repo.CreateAccount(ctx, account); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to create account")
                return nil, fmt.Errorf("failed to create account: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account created successfully")
        return account, nil</span>
}

// GetAccount retrieves an account by ID
func (s *service) GetAccount(ctx context.Context, userID, accountID uuid.UUID) (*Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", accountID.String()),
                ),
        )
        defer span.End()

        account, err := s.repo.GetAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return nil, fmt.Errorf("failed to get account: %w", err)
        }</span>

        // Check if account belongs to user
        <span class="cov0" title="0">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return nil, errors.New("account does not belong to user")
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account retrieved successfully")
        return account, nil</span>
}

// GetAccounts retrieves all accounts for a user
func (s *service) GetAccounts(ctx context.Context, userID uuid.UUID) ([]Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "GetAccounts",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                ),
        )
        defer span.End()

        accounts, err := s.repo.GetAccountsByUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get accounts")
                return nil, fmt.Errorf("failed to get accounts: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "accounts retrieved successfully")
        return accounts, nil</span>
}

// UpdateAccount updates an account
func (s *service) UpdateAccount(ctx context.Context, userID, accountID uuid.UUID, req *CreateAccountRequest) (*Account, error) <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "UpdateAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", accountID.String()),
                ),
        )
        defer span.End()

        account, err := s.repo.GetAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return nil, fmt.Errorf("failed to get account: %w", err)
        }</span>

        // Check if account belongs to user
        <span class="cov0" title="0">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return nil, errors.New("account does not belong to user")
        }</span>

        // Update fields
        <span class="cov0" title="0">account.Name = req.Name
        account.Type = req.Type
        account.Institution = req.Institution
        account.AccountNumberHash = req.AccountNumberHash
        account.Balance = req.Balance
        account.Currency = req.Currency
        account.PlaidAccountID = req.PlaidAccountID
        account.UpdatedAt = time.Now()

        if err := s.repo.UpdateAccount(ctx, account); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to update account")
                return nil, fmt.Errorf("failed to update account: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account updated successfully")
        return account, nil</span>
}

// DeleteAccount deletes an account
func (s *service) DeleteAccount(ctx context.Context, userID, accountID uuid.UUID) error <span class="cov0" title="0">{
        ctx, span := otel.Tracer("transaction").Start(ctx, "DeleteAccount",
                trace.WithAttributes(
                        attribute.String("user_id", userID.String()),
                        attribute.String("account_id", accountID.String()),
                ),
        )
        defer span.End()

        account, err := s.repo.GetAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to get account")
                return fmt.Errorf("failed to get account: %w", err)
        }</span>

        // Check if account belongs to user
        <span class="cov0" title="0">if account.UserID != userID </span><span class="cov0" title="0">{
                span.RecordError(errors.New("account does not belong to user"))
                span.SetStatus(codes.Error, "account does not belong to user")
                return errors.New("account does not belong to user")
        }</span>

        <span class="cov0" title="0">if err := s.repo.DeleteAccount(ctx, accountID); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.SetStatus(codes.Error, "failed to delete account")
                return fmt.Errorf("failed to delete account: %w", err)
        }</span>

        <span class="cov0" title="0">span.SetStatus(codes.Ok, "account deleted successfully")
        return nil</span>
}

// Helper methods

// toTransactionResponse converts a Transaction to TransactionResponse
func (s *service) toTransactionResponse(transaction *Transaction) *TransactionResponse <span class="cov10" title="4">{
        return &amp;TransactionResponse{
                ID:                       transaction.ID,
                UserID:                   transaction.UserID,
                FamilyID:                 transaction.FamilyID,
                AccountID:                transaction.AccountID,
                CategoryID:               transaction.CategoryID,
                Amount:                   transaction.Amount,
                Currency:                 transaction.Currency,
                Description:              transaction.Description,
                Merchant:                 transaction.Merchant,
                Location:                 transaction.Location,
                TransactionDate:          transaction.TransactionDate,
                PostedDate:               transaction.PostedDate,
                Status:                   transaction.Status,
                CategorizationSource:     transaction.CategorizationSource,
                CategorizationConfidence: transaction.CategorizationConfidence,
                Tags:                     transaction.Tags,
                Notes:                    transaction.Notes,
                ReceiptURL:               transaction.ReceiptURL,
                CreatedAt:                transaction.CreatedAt,
                UpdatedAt:                transaction.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package user

import (
        "time"

        "github.com/google/uuid"
)

// User represents a user in the system
type User struct {
        ID               uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Email            string     `json:"email" gorm:"unique;not null"`
        PasswordHash     string     `json:"-" gorm:"not null"`
        FirstName        string     `json:"first_name"`
        LastName         string     `json:"last_name"`
        Phone            string     `json:"phone"`
        DateOfBirth      *time.Time `json:"date_of_birth"`
        Timezone         string     `json:"timezone" gorm:"default:'UTC'"`
        Locale           string     `json:"locale" gorm:"default:'en-US'"`
        Role             UserRole   `json:"role" gorm:"default:'user'"`
        Status           UserStatus `json:"status" gorm:"default:'active'"`
        EmailVerified    bool       `json:"email_verified" gorm:"default:false"`
        PhoneVerified    bool       `json:"phone_verified" gorm:"default:false"`
        TwoFactorEnabled bool       `json:"two_factor_enabled" gorm:"default:false"`
        LastLoginAt      *time.Time `json:"last_login_at"`
        CreatedAt        time.Time  `json:"created_at"`
        UpdatedAt        time.Time  `json:"updated_at"`
}

// UserRole represents the role of a user
type UserRole string

const (
        UserRoleUser         UserRole = "user"
        UserRolePremium      UserRole = "premium"
        UserRoleAdmin        UserRole = "admin"
        UserRoleFamilyOwner  UserRole = "family_owner"
        UserRoleFamilyMember UserRole = "family_member"
)

// UserStatus represents the status of a user
type UserStatus string

const (
        UserStatusActive    UserStatus = "active"
        UserStatusInactive  UserStatus = "inactive"
        UserStatusSuspended UserStatus = "suspended"
        UserStatusDeleted   UserStatus = "deleted"
)

// DeviceInfo represents device information for a session
type DeviceInfo struct {
        DeviceType string `json:"device_type,omitempty"`
        OS         string `json:"os,omitempty"`
        Browser    string `json:"browser,omitempty"`
        DeviceID   string `json:"device_id,omitempty"`
        AppVersion string `json:"app_version,omitempty"`
}

// UserSession represents a user session
type UserSession struct {
        ID              uuid.UUID   `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        UserID          uuid.UUID   `json:"user_id" gorm:"type:uuid;not null"`
        RefreshToken    string      `json:"refresh_token" gorm:"unique;not null"`
        AccessTokenHash string      `json:"access_token_hash"`
        DeviceInfo      *DeviceInfo `json:"device_info" gorm:"type:jsonb"`
        IPAddress       string      `json:"ip_address"`
        UserAgent       string      `json:"user_agent"`
        ExpiresAt       time.Time   `json:"expires_at" gorm:"not null"`
        RevokedAt       *time.Time  `json:"revoked_at"`
        CreatedAt       time.Time   `json:"created_at"`
}

// CreateUserRequest represents a request to create a new user
type CreateUserRequest struct {
        Email     string `json:"email" binding:"required,email"`
        Password  string `json:"password" binding:"required,min=8"`
        FirstName string `json:"first_name" binding:"required"`
        LastName  string `json:"last_name" binding:"required"`
        Phone     string `json:"phone"`
        Timezone  string `json:"timezone"`
        Locale    string `json:"locale"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

// UpdateUserRequest represents a request to update a user
type UpdateUserRequest struct {
        FirstName   string     `json:"first_name"`
        LastName    string     `json:"last_name"`
        Phone       string     `json:"phone"`
        DateOfBirth *time.Time `json:"date_of_birth"`
        Timezone    string     `json:"timezone"`
        Locale      string     `json:"locale"`
}

// UserResponse represents a user response
type UserResponse struct {
        ID            uuid.UUID  `json:"id"`
        Email         string     `json:"email"`
        FirstName     string     `json:"first_name"`
        LastName      string     `json:"last_name"`
        Phone         string     `json:"phone"`
        DateOfBirth   *time.Time `json:"date_of_birth"`
        Timezone      string     `json:"timezone"`
        Locale        string     `json:"locale"`
        Role          UserRole   `json:"role"`
        Status        UserStatus `json:"status"`
        EmailVerified bool       `json:"email_verified"`
        PhoneVerified bool       `json:"phone_verified"`
        LastLoginAt   *time.Time `json:"last_login_at"`
        CreatedAt     time.Time  `json:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at"`
}

// TableName specifies the table name for User
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

// TableName specifies the table name for UserSession
func (UserSession) TableName() string <span class="cov0" title="0">{
        return "user_sessions"
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package user

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository defines the interface for user data operations
type Repository interface {
        Create(ctx context.Context, user *User) error
        GetByID(ctx context.Context, id uuid.UUID) (*User, error)
        GetByEmail(ctx context.Context, email string) (*User, error)
        Update(ctx context.Context, user *User) error
        Delete(ctx context.Context, id uuid.UUID) error
        List(ctx context.Context, offset, limit int) ([]User, error)
        CreateSession(ctx context.Context, session *UserSession) error
        GetSessionByRefreshToken(ctx context.Context, refreshToken string) (*UserSession, error)
        RevokeSession(ctx context.Context, sessionID uuid.UUID) error
        RevokeAllUserSessions(ctx context.Context, userID uuid.UUID) error
}

// repository implements the Repository interface
type repository struct {
        db *gorm.DB
}

// NewRepository creates a new user repository
func NewRepository(db *gorm.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Create creates a new user
func (r *repository) Create(ctx context.Context, user *User) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(user).Error
}</span>

// GetByID retrieves a user by ID
func (r *repository) GetByID(ctx context.Context, id uuid.UUID) (*User, error) <span class="cov0" title="0">{
        var user User
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetByEmail retrieves a user by email
func (r *repository) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{
        var user User
        err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// Update updates a user
func (r *repository) Update(ctx context.Context, user *User) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(user).Error
}</span>

// Delete deletes a user
func (r *repository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;User{}, id).Error
}</span>

// List retrieves a list of users with pagination
func (r *repository) List(ctx context.Context, offset, limit int) ([]User, error) <span class="cov0" title="0">{
        var users []User
        err := r.db.WithContext(ctx).Offset(offset).Limit(limit).Find(&amp;users).Error
        return users, err
}</span>

// CreateSession creates a new user session
func (r *repository) CreateSession(ctx context.Context, session *UserSession) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(session).Error
}</span>

// GetSessionByRefreshToken retrieves a session by refresh token
func (r *repository) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (*UserSession, error) <span class="cov0" title="0">{
        var session UserSession
        err := r.db.WithContext(ctx).Where("refresh_token = ? AND revoked_at IS NULL", refreshToken).First(&amp;session).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrSessionNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;session, nil</span>
}

// RevokeSession revokes a specific session
func (r *repository) RevokeSession(ctx context.Context, sessionID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;UserSession{}).Where("id = ?", sessionID).Update("revoked_at", gorm.Expr("NOW()")).Error
}</span>

// RevokeAllUserSessions revokes all sessions for a user
func (r *repository) RevokeAllUserSessions(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;UserSession{}).Where("user_id = ?", userID).Update("revoked_at", gorm.Expr("NOW()")).Error
}</span>

// Custom errors
var (
        ErrUserNotFound    = errors.New("user not found")
        ErrSessionNotFound = errors.New("session not found")
)
</pre>
		
		<pre class="file" id="file25" style="display: none">package user

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "errors"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// Service defines the interface for user business logic
type Service interface {
        Register(ctx context.Context, req *CreateUserRequest) (*UserResponse, error)
        Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error)
        GetProfile(ctx context.Context, userID uuid.UUID) (*UserResponse, error)
        UpdateProfile(ctx context.Context, userID uuid.UUID, req *UpdateUserRequest) (*UserResponse, error)
        RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error)
        Logout(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error
        ValidateToken(ctx context.Context, tokenString string) (*Claims, error)
}

// service implements the Service interface
type service struct {
        repo          Repository
        jwtSecret     string
        tokenExpiry   time.Duration
        refreshExpiry time.Duration
}

// NewService creates a new user service
func NewService(repo Repository, jwtSecret string) Service <span class="cov10" title="10">{
        return &amp;service{
                repo:          repo,
                jwtSecret:     jwtSecret,
                tokenExpiry:   15 * time.Minute,
                refreshExpiry: 7 * 24 * time.Hour, // 7 days
        }
}</span>

// Claims represents JWT claims
type Claims struct {
        UserID uuid.UUID `json:"user_id"`
        Email  string    `json:"email"`
        Role   UserRole  `json:"role"`
        jwt.RegisteredClaims
}

// LoginResponse represents a login response
type LoginResponse struct {
        User         *UserResponse `json:"user"`
        AccessToken  string        `json:"access_token"`
        RefreshToken string        `json:"refresh_token"`
        ExpiresIn    int64         `json:"expires_in"`
}

// Register creates a new user account
func (s *service) Register(ctx context.Context, req *CreateUserRequest) (*UserResponse, error) <span class="cov5" title="3">{
        // Check if user already exists
        existingUser, err := s.repo.GetByEmail(ctx, req.Email)
        if err != nil &amp;&amp; !errors.Is(err, ErrUserNotFound) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>
        <span class="cov3" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                return nil, ErrUserAlreadyExists
        }</span>

        // Hash password
        <span class="cov1" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Create user
        <span class="cov1" title="1">user := &amp;User{
                ID:           uuid.New(),
                Email:        req.Email,
                PasswordHash: string(hashedPassword),
                FirstName:    req.FirstName,
                LastName:     req.LastName,
                Phone:        req.Phone,
                Timezone:     req.Timezone,
                Locale:       req.Locale,
                Role:         UserRoleUser,
                Status:       UserStatusActive,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := s.repo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov1" title="1">return s.toUserResponse(user), nil</span>
}

// Login authenticates a user and returns tokens
func (s *service) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov5" title="3">{
        // Get user by email
        user, err := s.repo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, ErrUserNotFound) </span><span class="cov1" title="1">{
                        return nil, ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        // Check if user is active
        <span class="cov3" title="2">if user.Status != UserStatusActive </span><span class="cov1" title="1">{
                return nil, ErrUserInactive
        }</span>

        // Verify password
        <span class="cov1" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        // Update last login
        <span class="cov1" title="1">user.LastLoginAt = &amp;time.Time{}
        *user.LastLoginAt = time.Now()
        if err := s.repo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update last login: %w", err)
        }</span>

        // Generate tokens
        <span class="cov1" title="1">accessToken, err := s.generateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov1" title="1">refreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Create session
        <span class="cov1" title="1">session := &amp;UserSession{
                ID:           uuid.New(),
                UserID:       user.ID,
                RefreshToken: refreshToken,
                DeviceInfo:   nil, // Explicitly set to nil for JSONB field
                ExpiresAt:    time.Now().Add(s.refreshExpiry),
                CreatedAt:    time.Now(),
        }

        if err := s.repo.CreateSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;LoginResponse{
                User:         s.toUserResponse(user),
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(s.tokenExpiry.Seconds()),
        }, nil</span>
}

// GetProfile retrieves user profile
func (s *service) GetProfile(ctx context.Context, userID uuid.UUID) (*UserResponse, error) <span class="cov3" title="2">{
        user, err := s.repo.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return s.toUserResponse(user), nil</span>
}

// UpdateProfile updates user profile
func (s *service) UpdateProfile(ctx context.Context, userID uuid.UUID, req *UpdateUserRequest) (*UserResponse, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.FirstName != "" </span><span class="cov0" title="0">{
                user.FirstName = req.FirstName
        }</span>
        <span class="cov0" title="0">if req.LastName != "" </span><span class="cov0" title="0">{
                user.LastName = req.LastName
        }</span>
        <span class="cov0" title="0">if req.Phone != "" </span><span class="cov0" title="0">{
                user.Phone = req.Phone
        }</span>
        <span class="cov0" title="0">if req.DateOfBirth != nil </span><span class="cov0" title="0">{
                user.DateOfBirth = req.DateOfBirth
        }</span>
        <span class="cov0" title="0">if req.Timezone != "" </span><span class="cov0" title="0">{
                user.Timezone = req.Timezone
        }</span>
        <span class="cov0" title="0">if req.Locale != "" </span><span class="cov0" title="0">{
                user.Locale = req.Locale
        }</span>

        <span class="cov0" title="0">user.UpdatedAt = time.Now()

        if err := s.repo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return s.toUserResponse(user), nil</span>
}

// RefreshToken refreshes access token using refresh token
func (s *service) RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error) <span class="cov0" title="0">{
        // Get session by refresh token
        session, err := s.repo.GetSessionByRefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        // Check if session is expired
        <span class="cov0" title="0">if time.Now().After(session.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, ErrRefreshTokenExpired
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.repo.GetByID(ctx, session.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate new access token
        <span class="cov0" title="0">accessToken, err := s.generateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;LoginResponse{
                User:         s.toUserResponse(user),
                AccessToken:  accessToken,
                RefreshToken: refreshToken, // Return same refresh token
                ExpiresIn:    int64(s.tokenExpiry.Seconds()),
        }, nil</span>
}

// Logout logs out a user by revoking their session
func (s *service) Logout(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error <span class="cov0" title="0">{
        return s.repo.RevokeSession(ctx, sessionID)
}</span>

// ValidateToken validates and parses JWT token
func (s *service) ValidateToken(ctx context.Context, tokenString string) (*Claims, error) <span class="cov3" title="2">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(s.jwtSecret), nil</span>
        })

        <span class="cov3" title="2">if err != nil </span><span class="cov3" title="2">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, ErrInvalidToken</span>
}

// generateAccessToken generates a JWT access token
func (s *service) generateAccessToken(user *User) (string, error) <span class="cov3" title="2">{
        claims := &amp;Claims{
                UserID: user.ID,
                Email:  user.Email,
                Role:   user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(s.tokenExpiry)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "fiscaflow",
                        Subject:   user.ID.String(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>

// generateRefreshToken generates a secure refresh token
func (s *service) generateRefreshToken() (string, error) <span class="cov3" title="2">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="2">return hex.EncodeToString(bytes), nil</span>
}

// toUserResponse converts User to UserResponse
func (s *service) toUserResponse(user *User) *UserResponse <span class="cov5" title="3">{
        return &amp;UserResponse{
                ID:            user.ID,
                Email:         user.Email,
                FirstName:     user.FirstName,
                LastName:      user.LastName,
                Phone:         user.Phone,
                DateOfBirth:   user.DateOfBirth,
                Timezone:      user.Timezone,
                Locale:        user.Locale,
                Role:          user.Role,
                Status:        user.Status,
                EmailVerified: user.EmailVerified,
                PhoneVerified: user.PhoneVerified,
                LastLoginAt:   user.LastLoginAt,
                CreatedAt:     user.CreatedAt,
                UpdatedAt:     user.UpdatedAt,
        }
}</span>

// Custom errors
var (
        ErrUserAlreadyExists   = errors.New("user already exists")
        ErrInvalidCredentials  = errors.New("invalid credentials")
        ErrUserInactive        = errors.New("user account is inactive")
        ErrInvalidRefreshToken = errors.New("invalid refresh token")
        ErrRefreshTokenExpired = errors.New("refresh token expired")
        ErrInvalidToken        = errors.New("invalid token")
)
 </pre>
		
		<pre class="file" id="file26" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "fiscaflow/internal/domain/analytics"
        "fiscaflow/internal/domain/budget"
        "fiscaflow/internal/domain/transaction"
        "fiscaflow/internal/domain/user"
)

// Config represents database configuration
type Config struct {
        Host            string
        Port            int
        User            string
        Password        string
        DBName          string
        SSLMode         string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
}

// Database represents the database connection
type Database struct {
        DB *gorm.DB
}

// NewDatabase creates a new database connection
func NewDatabase(config *Config) (*Database, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(config.MaxOpenConns)
        sqlDB.SetMaxIdleConns(config.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)

        return &amp;Database{DB: db}, nil</span>
}

// AutoMigrate runs database migrations
func (d *Database) AutoMigrate() error <span class="cov0" title="0">{
        return d.DB.AutoMigrate(
                &amp;user.User{},
                &amp;user.UserSession{},
                &amp;transaction.Transaction{},
                &amp;transaction.Category{},
                &amp;transaction.Account{},
                &amp;budget.Budget{},
                &amp;budget.BudgetCategory{},
                &amp;analytics.CategorizationModel{},
                &amp;analytics.CategorizationRule{},
                &amp;analytics.SpendingAnalysis{},
        )
}</span>

// Ping checks database connectivity
func (d *Database) Ping(ctx context.Context) error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov0" title="0">return sqlDB.PingContext(ctx)</span>
}

// Close closes the database connection
func (d *Database) Close() error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov0" title="0">return sqlDB.Close()</span>
}

// GetDB returns the underlying GORM DB instance
func (d *Database) GetDB() *gorm.DB <span class="cov0" title="0">{
        return d.DB
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package logging

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewLogger creates a new configured logger
func NewLogger() *zap.Logger <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        config.EncoderConfig.TimeKey = "timestamp"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        config.EncoderConfig.StacktraceKey = "stacktrace"
        config.EncoderConfig.MessageKey = "message"
        config.EncoderConfig.LevelKey = "level"
        config.EncoderConfig.CallerKey = "caller"

        logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize logger: " + err.Error())</span>
        }

        <span class="cov0" title="0">return logger</span>
}

// GinLogger returns a gin.HandlerFunc for logging HTTP requests
func GinLogger(logger *zap.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                logger.Info("HTTP Request",
                        zap.String("method", param.Method),
                        zap.String("path", param.Path),
                        zap.Int("status", param.StatusCode),
                        zap.Duration("latency", param.Latency),
                        zap.String("client_ip", param.ClientIP),
                        zap.String("user_agent", param.Request.UserAgent()),
                        zap.Time("timestamp", param.TimeStamp),
                )
                return ""
        }</span>)
}

// WithTraceID adds trace ID to logger context
func WithTraceID(logger *zap.Logger, traceID string) *zap.Logger <span class="cov0" title="0">{
        return logger.With(zap.String("trace_id", traceID))
}</span>

// WithUserID adds user ID to logger context
func WithUserID(logger *zap.Logger, userID string) *zap.Logger <span class="cov0" title="0">{
        return logger.With(zap.String("user_id", userID))
}</span>

// WithRequestID adds request ID to logger context
func WithRequestID(logger *zap.Logger, requestID string) *zap.Logger <span class="cov0" title="0">{
        return logger.With(zap.String("request_id", requestID))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package tracing

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// InitTracer initializes OpenTelemetry tracer
func InitTracer(endpoint string) (*sdktrace.TracerProvider, error) <span class="cov0" title="0">{
        // Create OTLP gRPC exporter
        client := otlptracegrpc.NewClient(
                otlptracegrpc.WithEndpoint(endpoint),
                otlptracegrpc.WithInsecure(),
        )
        exporter, err := otlptrace.New(context.Background(), client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        }</span>

        // Create resource
        <span class="cov0" title="0">res, err := resource.New(context.Background(),
                resource.WithAttributes(
                        semconv.ServiceName("fiscaflow"),
                        semconv.ServiceVersion("1.0.0"),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Create tracer provider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
        )

        return tp, nil</span>
}

// ShutdownTracer gracefully shuts down the tracer
func ShutdownTracer(tp *sdktrace.TracerProvider, ctx context.Context) error <span class="cov0" title="0">{
        return tp.Shutdown(ctx)
}</span>
 </pre>
		
		<pre class="file" id="file29" style="display: none">package integration

import (
        "testing"
        "time"

        "github.com/stretchr/testify/require"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

// TestDatabase represents a test database setup
// (reused by both user and transaction integration tests)
type TestDatabase struct {
        DB *gorm.DB
}

// NewTestDatabase creates a new test database using SQLite in memory
func NewTestDatabase(t *testing.T) *TestDatabase <span class="cov10" title="13">{
        db, err := gorm.Open(sqlite.Open(":memory:"), &amp;gorm.Config{})
        require.NoError(t, err)

        // Auto-migrate the schema with all models needed for integration tests
        err = db.AutoMigrate(
                &amp;TestUser{}, &amp;TestUserSession{},
                &amp;TestTransaction{}, &amp;TestCategory{}, &amp;TestAccount{},
        )
        require.NoError(t, err)

        return &amp;TestDatabase{DB: db}
}</span>

// Cleanup cleans up the test database
func (td *TestDatabase) Cleanup() <span class="cov9" title="11">{
        td.DB.Exec("DELETE FROM transactions")
        td.DB.Exec("DELETE FROM categories")
        td.DB.Exec("DELETE FROM accounts")
        td.DB.Exec("DELETE FROM user_sessions")
        td.DB.Exec("DELETE FROM users")
}</span>

// TestUser is a SQLite-compatible version of the User model for integration tests
type TestUser struct {
        ID               string     `json:"id" gorm:"type:text;primary_key"`
        Email            string     `json:"email" gorm:"unique;not null"`
        PasswordHash     string     `json:"-" gorm:"not null"`
        FirstName        string     `json:"first_name"`
        LastName         string     `json:"last_name"`
        Phone            string     `json:"phone"`
        DateOfBirth      *time.Time `json:"date_of_birth"`
        Timezone         string     `json:"timezone" gorm:"default:'UTC'"`
        Locale           string     `json:"locale" gorm:"default:'en-US'"`
        Role             string     `json:"role" gorm:"default:'user'"`
        Status           string     `json:"status" gorm:"default:'active'"`
        EmailVerified    bool       `json:"email_verified" gorm:"default:false"`
        PhoneVerified    bool       `json:"phone_verified" gorm:"default:false"`
        TwoFactorEnabled bool       `json:"two_factor_enabled" gorm:"default:false"`
        LastLoginAt      *time.Time `json:"last_login_at"`
        CreatedAt        time.Time  `json:"created_at"`
        UpdatedAt        time.Time  `json:"updated_at"`
}

// TableName specifies the table name for TestUser
func (TestUser) TableName() string <span class="cov10" title="13">{
        return "users"
}</span>

// TestUserSession is a SQLite-compatible version of the UserSession model
// DeviceInfo is stored as a JSON string
type TestUserSession struct {
        ID              string     `json:"id" gorm:"type:text;primary_key"`
        UserID          string     `json:"user_id" gorm:"type:text;not null"`
        RefreshToken    string     `json:"refresh_token" gorm:"unique;not null"`
        AccessTokenHash string     `json:"access_token_hash"`
        DeviceInfo      string     `json:"device_info" gorm:"type:text"` // Store as JSON string for SQLite
        IPAddress       string     `json:"ip_address"`
        UserAgent       string     `json:"user_agent"`
        ExpiresAt       time.Time  `json:"expires_at" gorm:"not null"`
        RevokedAt       *time.Time `json:"revoked_at"`
        CreatedAt       time.Time  `json:"created_at"`
}

// TableName specifies the table name for TestUserSession
func (TestUserSession) TableName() string <span class="cov10" title="13">{
        return "user_sessions"
}</span>

// TestTransaction is a SQLite-compatible version of the Transaction model for integration tests
type TestTransaction struct {
        ID         string  `json:"id" gorm:"type:text;primary_key"`
        UserID     string  `json:"user_id" gorm:"type:text;not null"`
        FamilyID   *string `json:"family_id" gorm:"type:text"`
        AccountID  string  `json:"account_id" gorm:"type:text;not null"`
        CategoryID *string `json:"category_id" gorm:"type:text"`

        Amount      float64 `json:"amount" gorm:"type:decimal(15,2);not null"`
        Currency    string  `json:"currency" gorm:"default:'USD'"`
        Description string  `json:"description" gorm:"not null"`
        Merchant    string  `json:"merchant"`
        Location    string  `json:"location" gorm:"type:text"`

        TransactionDate time.Time  `json:"transaction_date" gorm:"not null"`
        PostedDate      *time.Time `json:"posted_date"`
        Status          string     `json:"status" gorm:"default:'pending'"`

        CategorizationSource     string   `json:"categorization_source" gorm:"default:'manual'"`
        CategorizationConfidence *float64 `json:"categorization_confidence"`

        Tags       string `json:"tags" gorm:"type:text"` // Store as JSON string for SQLite
        Notes      string `json:"notes"`
        ReceiptURL string `json:"receipt_url"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// TableName specifies the table name for TestTransaction
func (TestTransaction) TableName() string <span class="cov10" title="13">{
        return "transactions"
}</span>

// TestCategory is a SQLite-compatible version of the Category model for integration tests
type TestCategory struct {
        ID          string    `json:"id" gorm:"type:text;primary_key"`
        Name        string    `json:"name" gorm:"not null"`
        Description string    `json:"description"`
        Icon        string    `json:"icon"`
        Color       string    `json:"color"`
        ParentID    *string   `json:"parent_id" gorm:"type:text"`
        IsDefault   bool      `json:"is_default" gorm:"default:false"`
        IsActive    bool      `json:"is_active" gorm:"default:true"`
        SortOrder   int       `json:"sort_order" gorm:"default:0"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// TableName specifies the table name for TestCategory
func (TestCategory) TableName() string <span class="cov10" title="13">{
        return "categories"
}</span>

// TestAccount is a SQLite-compatible version of the Account model for integration tests
type TestAccount struct {
        ID                string     `json:"id" gorm:"type:text;primary_key"`
        UserID            string     `json:"user_id" gorm:"type:text;not null"`
        FamilyID          *string    `json:"family_id" gorm:"type:text"`
        Name              string     `json:"name" gorm:"not null"`
        Type              string     `json:"type" gorm:"not null"`
        Institution       string     `json:"institution"`
        AccountNumberHash string     `json:"account_number_hash"`
        Balance           float64    `json:"balance" gorm:"type:decimal(15,2);default:0.00"`
        Currency          string     `json:"currency" gorm:"default:'USD'"`
        IsActive          bool       `json:"is_active" gorm:"default:true"`
        PlaidAccountID    string     `json:"plaid_account_id"`
        LastSyncAt        *time.Time `json:"last_sync_at"`
        Settings          string     `json:"settings" gorm:"type:text;default:'{}'"` // Store as JSON string for SQLite
        CreatedAt         time.Time  `json:"created_at"`
        UpdatedAt         time.Time  `json:"updated_at"`
}

// TableName specifies the table name for TestAccount
func (TestAccount) TableName() string <span class="cov10" title="13">{
        return "accounts"
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
